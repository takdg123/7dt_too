{"ast":null,"code":"import _objectSpread from \"/Users/dtak/Research/ToO/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\n/*!\n* chartjs-plugin-annotation v3.1.0\n* https://www.chartjs.org/chartjs-plugin-annotation/index\n * (c) 2024 chartjs-plugin-annotation Contributors\n * Released under the MIT License\n */\nimport { Element, DoughnutController, defaults, Animations, Chart } from 'chart.js';\nimport { distanceBetweenPoints, toRadians, isObject, valueOrDefault, defined, isFunction, callback, isArray, toFont, addRoundedRectPath, toTRBLCorners, QUARTER_PI, PI, HALF_PI, TWO_THIRDS_PI, TAU, isNumber, RAD_PER_DEG, toPadding, isFinite, getAngleFromPoint, toDegrees, clipArea, unclipArea } from 'chart.js/helpers';\n\n/**\n * @typedef { import(\"chart.js\").ChartEvent } ChartEvent\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */\n\nconst interaction = {\n  modes: {\n    /**\n     * Point mode returns all elements that hit test based on the event position\n     * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n     * @param {ChartEvent} event - the event we are find things at\n     * @return {AnnotationElement[]} - elements that are found\n     */\n    point(visibleElements, event) {\n      return filterElements(visibleElements, event, {\n        intersect: true\n      });\n    },\n    /**\n     * Nearest mode returns the element closest to the event position\n     * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n     * @param {ChartEvent} event - the event we are find things at\n     * @param {Object} options - interaction options to use\n     * @return {AnnotationElement[]} - elements that are found (only 1 element)\n     */\n    nearest(visibleElements, event, options) {\n      return getNearestItem(visibleElements, event, options);\n    },\n    /**\n     * x mode returns the elements that hit-test at the current x coordinate\n     * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n     * @param {ChartEvent} event - the event we are find things at\n     * @param {Object} options - interaction options to use\n     * @return {AnnotationElement[]} - elements that are found\n     */\n    x(visibleElements, event, options) {\n      return filterElements(visibleElements, event, {\n        intersect: options.intersect,\n        axis: 'x'\n      });\n    },\n    /**\n     * y mode returns the elements that hit-test at the current y coordinate\n     * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n     * @param {ChartEvent} event - the event we are find things at\n     * @param {Object} options - interaction options to use\n     * @return {AnnotationElement[]} - elements that are found\n     */\n    y(visibleElements, event, options) {\n      return filterElements(visibleElements, event, {\n        intersect: options.intersect,\n        axis: 'y'\n      });\n    }\n  }\n};\n\n/**\n * Returns all elements that hit test based on the event position\n * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n * @param {ChartEvent} event - the event we are find things at\n * @param {Object} options - interaction options to use\n * @return {AnnotationElement[]} - elements that are found\n */\nfunction getElements(visibleElements, event, options) {\n  const mode = interaction.modes[options.mode] || interaction.modes.nearest;\n  return mode(visibleElements, event, options);\n}\nfunction inRangeByAxis(element, event, axis) {\n  if (axis !== 'x' && axis !== 'y') {\n    return element.inRange(event.x, event.y, 'x', true) || element.inRange(event.x, event.y, 'y', true);\n  }\n  return element.inRange(event.x, event.y, axis, true);\n}\nfunction getPointByAxis(event, center, axis) {\n  if (axis === 'x') {\n    return {\n      x: event.x,\n      y: center.y\n    };\n  } else if (axis === 'y') {\n    return {\n      x: center.x,\n      y: event.y\n    };\n  }\n  return center;\n}\nfunction filterElements(visibleElements, event, options) {\n  return visibleElements.filter(element => options.intersect ? element.inRange(event.x, event.y) : inRangeByAxis(element, event, options.axis));\n}\nfunction getNearestItem(visibleElements, event, options) {\n  let minDistance = Number.POSITIVE_INFINITY;\n  return filterElements(visibleElements, event, options).reduce((nearestItems, element) => {\n    const center = element.getCenterPoint();\n    const evenPoint = getPointByAxis(event, center, options.axis);\n    const distance = distanceBetweenPoints(event, evenPoint);\n    if (distance < minDistance) {\n      nearestItems = [element];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      // Can have multiple items at the same distance in which case we sort by size\n      nearestItems.push(element);\n    }\n    return nearestItems;\n  }, []).sort((a, b) => a._index - b._index).slice(0, 1); // return only the top item;\n}\n\n/**\n * @typedef {import('chart.js').Point} Point\n */\n\n/**\n * Rotate a `point` relative to `center` point by `angle`\n * @param {Point} point - the point to rotate\n * @param {Point} center - center point for rotation\n * @param {number} angle - angle for rotation, in radians\n * @returns {Point} rotated point\n */\nfunction rotated(point, center, angle) {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  const cx = center.x;\n  const cy = center.y;\n  return {\n    x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n    y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n  };\n}\nconst isOlderPart = (act, req) => req > act || act.length > req.length && act.slice(0, req.length) === req;\n\n/**\n * @typedef { import('chart.js').Point } Point\n * @typedef { import('chart.js').InteractionAxis } InteractionAxis\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */\n\nconst EPSILON = 0.001;\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\n\n/**\n * @param {{value: number, start: number, end: number}} limit\n * @param {number} hitSize\n * @returns {boolean}\n */\nconst inLimit = (limit, hitSize) => limit.value >= limit.start - hitSize && limit.value <= limit.end + hitSize;\n\n/**\n * @param {Object} obj\n * @param {number} from\n * @param {number} to\n * @returns {Object}\n */\nfunction clampAll(obj, from, to) {\n  for (const key of Object.keys(obj)) {\n    obj[key] = clamp(obj[key], from, to);\n  }\n  return obj;\n}\n\n/**\n * @param {Point} point\n * @param {Point} center\n * @param {number} radius\n * @param {number} hitSize\n * @returns {boolean}\n */\nfunction inPointRange(point, center, radius, hitSize) {\n  if (!point || !center || radius <= 0) {\n    return false;\n  }\n  return Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2) <= Math.pow(radius + hitSize, 2);\n}\n\n/**\n * @param {Point} point\n * @param {{x: number, y: number, x2: number, y2: number}} rect\n * @param {InteractionAxis} axis\n * @param {{borderWidth: number, hitTolerance: number}} hitsize\n * @returns {boolean}\n */\nfunction inBoxRange(point, _ref, axis, _ref2) {\n  let {\n    x,\n    y,\n    x2,\n    y2\n  } = _ref;\n  let {\n    borderWidth,\n    hitTolerance\n  } = _ref2;\n  const hitSize = (borderWidth + hitTolerance) / 2;\n  const inRangeX = point.x >= x - hitSize - EPSILON && point.x <= x2 + hitSize + EPSILON;\n  const inRangeY = point.y >= y - hitSize - EPSILON && point.y <= y2 + hitSize + EPSILON;\n  if (axis === 'x') {\n    return inRangeX;\n  } else if (axis === 'y') {\n    return inRangeY;\n  }\n  return inRangeX && inRangeY;\n}\n\n/**\n * @param {Point} point\n * @param {rect: {x: number, y: number, x2: number, y2: number}, center: {x: number, y: number}} element\n * @param {InteractionAxis} axis\n * @param {{rotation: number, borderWidth: number, hitTolerance: number}}\n * @returns {boolean}\n */\nfunction inLabelRange(point, _ref3, axis, _ref4) {\n  let {\n    rect,\n    center\n  } = _ref3;\n  let {\n    rotation,\n    borderWidth,\n    hitTolerance\n  } = _ref4;\n  const rotPoint = rotated(point, center, toRadians(-rotation));\n  return inBoxRange(rotPoint, rect, axis, {\n    borderWidth,\n    hitTolerance\n  });\n}\n\n/**\n * @param {AnnotationElement} element\n * @param {boolean} useFinalPosition\n * @returns {Point}\n */\nfunction getElementCenterPoint(element, useFinalPosition) {\n  const {\n    centerX,\n    centerY\n  } = element.getProps(['centerX', 'centerY'], useFinalPosition);\n  return {\n    x: centerX,\n    y: centerY\n  };\n}\n\n/**\n * @param {string} pkg\n * @param {string} min\n * @param {string} ver\n * @param {boolean} [strict=true]\n * @returns {boolean}\n */\nfunction requireVersion(pkg, min, ver) {\n  let strict = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  const parts = ver.split('.');\n  let i = 0;\n  for (const req of min.split('.')) {\n    const act = parts[i++];\n    if (parseInt(req, 10) < parseInt(act, 10)) {\n      break;\n    }\n    if (isOlderPart(act, req)) {\n      if (strict) {\n        throw new Error(\"\".concat(pkg, \" v\").concat(ver, \" is not supported. v\").concat(min, \" or newer is required.\"));\n      } else {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nconst isPercentString = s => typeof s === 'string' && s.endsWith('%');\nconst toPercent = s => parseFloat(s) / 100;\nconst toPositivePercent = s => clamp(toPercent(s), 0, 1);\nconst boxAppering = (x, y) => ({\n  x,\n  y,\n  x2: x,\n  y2: y,\n  width: 0,\n  height: 0\n});\nconst defaultInitAnimation = {\n  box: properties => boxAppering(properties.centerX, properties.centerY),\n  doughnutLabel: properties => boxAppering(properties.centerX, properties.centerY),\n  ellipse: properties => ({\n    centerX: properties.centerX,\n    centerY: properties.centerX,\n    radius: 0,\n    width: 0,\n    height: 0\n  }),\n  label: properties => boxAppering(properties.centerX, properties.centerY),\n  line: properties => boxAppering(properties.x, properties.y),\n  point: properties => ({\n    centerX: properties.centerX,\n    centerY: properties.centerY,\n    radius: 0,\n    width: 0,\n    height: 0\n  }),\n  polygon: properties => boxAppering(properties.centerX, properties.centerY)\n};\n\n/**\n * @typedef { import('chart.js').FontSpec } FontSpec\n * @typedef { import('chart.js').Point } Point\n * @typedef { import('chart.js').Padding } Padding\n * @typedef { import('../../types/element').AnnotationBoxModel } AnnotationBoxModel\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n * @typedef { import('../../types/options').AnnotationPointCoordinates } AnnotationPointCoordinates\n * @typedef { import('../../types/label').CoreLabelOptions } CoreLabelOptions\n * @typedef { import('../../types/label').LabelPositionObject } LabelPositionObject\n */\n\n/**\n * @param {number} size\n * @param {number|string} position\n * @returns {number}\n */\nfunction getRelativePosition(size, position) {\n  if (position === 'start') {\n    return 0;\n  }\n  if (position === 'end') {\n    return size;\n  }\n  if (isPercentString(position)) {\n    return toPositivePercent(position) * size;\n  }\n  return size / 2;\n}\n\n/**\n * @param {number} size\n * @param {number|string} value\n * @param {boolean} [positivePercent=true]\n * @returns {number}\n */\nfunction getSize(size, value) {\n  let positivePercent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (typeof value === 'number') {\n    return value;\n  } else if (isPercentString(value)) {\n    return (positivePercent ? toPositivePercent(value) : toPercent(value)) * size;\n  }\n  return size;\n}\n\n/**\n * @param {{x: number, width: number}} size\n * @param {CoreLabelOptions} options\n * @returns {number}\n */\nfunction calculateTextAlignment(size, options) {\n  const {\n    x,\n    width\n  } = size;\n  const textAlign = options.textAlign;\n  if (textAlign === 'center') {\n    return x + width / 2;\n  } else if (textAlign === 'end' || textAlign === 'right') {\n    return x + width;\n  }\n  return x;\n}\n\n/**\n * @param {Point} point\n * @param {{height: number, width: number}} labelSize\n * @param {{borderWidth: number, position: {LabelPositionObject|string}, xAdjust: number, yAdjust: number}} options\n * @param {Padding|undefined} padding\n * @returns {{x: number, y: number, x2: number, y2: number, height: number, width: number, centerX: number, centerY: number}}\n */\nfunction measureLabelRectangle(point, labelSize, _ref5, padding) {\n  let {\n    borderWidth,\n    position,\n    xAdjust,\n    yAdjust\n  } = _ref5;\n  const hasPadding = isObject(padding);\n  const width = labelSize.width + (hasPadding ? padding.width : 0) + borderWidth;\n  const height = labelSize.height + (hasPadding ? padding.height : 0) + borderWidth;\n  const positionObj = toPosition(position);\n  const x = calculateLabelPosition$1(point.x, width, xAdjust, positionObj.x);\n  const y = calculateLabelPosition$1(point.y, height, yAdjust, positionObj.y);\n  return {\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n    width,\n    height,\n    centerX: x + width / 2,\n    centerY: y + height / 2\n  };\n}\n\n/**\n * @param {LabelPositionObject|string} value\n * @param {string|number} defaultValue\n * @returns {LabelPositionObject}\n */\nfunction toPosition(value) {\n  let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'center';\n  if (isObject(value)) {\n    return {\n      x: valueOrDefault(value.x, defaultValue),\n      y: valueOrDefault(value.y, defaultValue)\n    };\n  }\n  value = valueOrDefault(value, defaultValue);\n  return {\n    x: value,\n    y: value\n  };\n}\n\n/**\n * @param {CoreLabelOptions} options\n * @param {number} fitRatio\n * @returns {boolean}\n */\nconst shouldFit = (options, fitRatio) => options && options.autoFit && fitRatio < 1;\n\n/**\n * @param {CoreLabelOptions} options\n * @param {number} fitRatio\n * @returns {FontSpec[]}\n */\nfunction toFonts(options, fitRatio) {\n  const optFont = options.font;\n  const fonts = isArray(optFont) ? optFont : [optFont];\n  if (shouldFit(options, fitRatio)) {\n    return fonts.map(function (f) {\n      const font = toFont(f);\n      font.size = Math.floor(f.size * fitRatio);\n      font.lineHeight = f.lineHeight;\n      return toFont(font);\n    });\n  }\n  return fonts.map(f => toFont(f));\n}\n\n/**\n * @param {AnnotationPointCoordinates} options\n * @returns {boolean}\n */\nfunction isBoundToPoint(options) {\n  return options && (defined(options.xValue) || defined(options.yValue));\n}\nfunction calculateLabelPosition$1(start, size) {\n  let adjust = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let position = arguments.length > 3 ? arguments[3] : undefined;\n  return start - getRelativePosition(size, position) + adjust;\n}\n\n/**\n * @param {Chart} chart\n * @param {AnnotationBoxModel} properties\n * @param {CoreAnnotationOptions} options\n * @returns {AnnotationElement}\n */\nfunction initAnimationProperties(chart, properties, options) {\n  const initAnim = options.init;\n  if (!initAnim) {\n    return;\n  } else if (initAnim === true) {\n    return applyDefault(properties, options);\n  }\n  return execCallback(chart, properties, options);\n}\n\n/**\n * @param {Object} options\n * @param {Array} hooks\n * @param {Object} hooksContainer\n * @returns {boolean}\n */\nfunction loadHooks(options, hooks, hooksContainer) {\n  let activated = false;\n  hooks.forEach(hook => {\n    if (isFunction(options[hook])) {\n      activated = true;\n      hooksContainer[hook] = options[hook];\n    } else if (defined(hooksContainer[hook])) {\n      delete hooksContainer[hook];\n    }\n  });\n  return activated;\n}\nfunction applyDefault(properties, options) {\n  const type = options.type || 'line';\n  return defaultInitAnimation[type](properties);\n}\nfunction execCallback(chart, properties, options) {\n  const result = callback(options.init, [{\n    chart,\n    properties,\n    options\n  }]);\n  if (result === true) {\n    return applyDefault(properties, options);\n  } else if (isObject(result)) {\n    return result;\n  }\n}\nconst widthCache = new Map();\nconst notRadius = radius => isNaN(radius) || radius <= 0;\nconst fontsKey = fonts => fonts.reduce(function (prev, item) {\n  prev += item.string;\n  return prev;\n}, '');\n\n/**\n * @typedef { import('chart.js').Point } Point\n * @typedef { import('../../types/label').CoreLabelOptions } CoreLabelOptions\n * @typedef { import('../../types/options').PointAnnotationOptions } PointAnnotationOptions\n */\n\n/**\n * Determine if content is an image or a canvas.\n * @param {*} content\n * @returns boolean|undefined\n * @todo move this function to chart.js helpers\n */\nfunction isImageOrCanvas(content) {\n  if (content && typeof content === 'object') {\n    const type = content.toString();\n    return type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]';\n  }\n}\n\n/**\n * Set the translation on the canvas if the rotation must be applied.\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {Point} point - the point of translation\n * @param {number} rotation - rotation (in degrees) to apply\n */\nfunction translate(ctx, _ref6, rotation) {\n  let {\n    x,\n    y\n  } = _ref6;\n  if (rotation) {\n    ctx.translate(x, y);\n    ctx.rotate(toRadians(rotation));\n    ctx.translate(-x, -y);\n  }\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {Object} options\n * @returns {boolean|undefined}\n */\nfunction setBorderStyle(ctx, options) {\n  if (options && options.borderWidth) {\n    ctx.lineCap = options.borderCapStyle || 'butt';\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.lineJoin = options.borderJoinStyle || 'miter';\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    return true;\n  }\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {Object} options\n */\nfunction setShadowStyle(ctx, options) {\n  ctx.shadowColor = options.backgroundShadowColor;\n  ctx.shadowBlur = options.shadowBlur;\n  ctx.shadowOffsetX = options.shadowOffsetX;\n  ctx.shadowOffsetY = options.shadowOffsetY;\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {CoreLabelOptions} options\n * @returns {{width: number, height: number}}\n */\nfunction measureLabelSize(ctx, options) {\n  const content = options.content;\n  if (isImageOrCanvas(content)) {\n    const size = {\n      width: getSize(content.width, options.width),\n      height: getSize(content.height, options.height)\n    };\n    return size;\n  }\n  const fonts = toFonts(options);\n  const strokeWidth = options.textStrokeWidth;\n  const lines = isArray(content) ? content : [content];\n  const mapKey = lines.join() + fontsKey(fonts) + strokeWidth + (ctx._measureText ? '-spriting' : '');\n  if (!widthCache.has(mapKey)) {\n    widthCache.set(mapKey, calculateLabelSize(ctx, lines, fonts, strokeWidth));\n  }\n  return widthCache.get(mapKey);\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {{x: number, y: number, width: number, height: number}} rect\n * @param {Object} options\n */\nfunction drawBox(ctx, rect, options) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  ctx.save();\n  setShadowStyle(ctx, options);\n  const stroke = setBorderStyle(ctx, options);\n  ctx.fillStyle = options.backgroundColor;\n  ctx.beginPath();\n  addRoundedRectPath(ctx, {\n    x,\n    y,\n    w: width,\n    h: height,\n    radius: clampAll(toTRBLCorners(options.borderRadius), 0, Math.min(width, height) / 2)\n  });\n  ctx.closePath();\n  ctx.fill();\n  if (stroke) {\n    ctx.shadowColor = options.borderShadowColor;\n    ctx.stroke();\n  }\n  ctx.restore();\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {{x: number, y: number, width: number, height: number}} rect\n * @param {CoreLabelOptions} options\n * @param {number} fitRatio\n */\nfunction drawLabel(ctx, rect, options, fitRatio) {\n  const content = options.content;\n  if (isImageOrCanvas(content)) {\n    ctx.save();\n    ctx.globalAlpha = getOpacity(options.opacity, content.style.opacity);\n    ctx.drawImage(content, rect.x, rect.y, rect.width, rect.height);\n    ctx.restore();\n    return;\n  }\n  const labels = isArray(content) ? content : [content];\n  const fonts = toFonts(options, fitRatio);\n  const optColor = options.color;\n  const colors = isArray(optColor) ? optColor : [optColor];\n  const x = calculateTextAlignment(rect, options);\n  const y = rect.y + options.textStrokeWidth / 2;\n  ctx.save();\n  ctx.textBaseline = 'middle';\n  ctx.textAlign = options.textAlign;\n  if (setTextStrokeStyle(ctx, options)) {\n    applyLabelDecoration(ctx, {\n      x,\n      y\n    }, labels, fonts);\n  }\n  applyLabelContent(ctx, {\n    x,\n    y\n  }, labels, {\n    fonts,\n    colors\n  });\n  ctx.restore();\n}\nfunction setTextStrokeStyle(ctx, options) {\n  if (options.textStrokeWidth > 0) {\n    // https://stackoverflow.com/questions/13627111/drawing-text-with-an-outer-stroke-with-html5s-canvas\n    ctx.lineJoin = 'round';\n    ctx.miterLimit = 2;\n    ctx.lineWidth = options.textStrokeWidth;\n    ctx.strokeStyle = options.textStrokeColor;\n    return true;\n  }\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {{radius: number, options: PointAnnotationOptions}} element\n * @param {number} x\n * @param {number} y\n */\nfunction drawPoint(ctx, element, x, y) {\n  const {\n    radius,\n    options\n  } = element;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n  if (isImageOrCanvas(style)) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(rad);\n    ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n    ctx.restore();\n    return;\n  }\n  if (notRadius(radius)) {\n    return;\n  }\n  drawPointStyle(ctx, {\n    x,\n    y,\n    radius,\n    rotation,\n    style,\n    rad\n  });\n}\nfunction drawPointStyle(ctx, _ref7) {\n  let {\n    x,\n    y,\n    radius,\n    rotation,\n    style,\n    rad\n  } = _ref7;\n  let xOffset, yOffset, size, cornerRadius;\n  ctx.beginPath();\n  switch (style) {\n    // Default includes circle\n    default:\n      ctx.arc(x, y, radius, 0, TAU);\n      ctx.closePath();\n      break;\n    case 'triangle':\n      ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n      ctx.closePath();\n      break;\n    case 'rectRounded':\n      // NOTE: the rounded rect implementation changed to use `arc` instead of\n      // `quadraticCurveTo` since it generates better results when rect is\n      // almost a circle. 0.516 (instead of 0.5) produces results with visually\n      // closer proportion to the previous impl and it is inscribed in the\n      // circle with `radius`. For more details, see the following PRs:\n      // https://github.com/chartjs/Chart.js/issues/5597\n      // https://github.com/chartjs/Chart.js/issues/5858\n      cornerRadius = radius * 0.516;\n      size = radius - cornerRadius;\n      xOffset = Math.cos(rad + QUARTER_PI) * size;\n      yOffset = Math.sin(rad + QUARTER_PI) * size;\n      ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n      ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n      ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n      ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n      ctx.closePath();\n      break;\n    case 'rect':\n      if (!rotation) {\n        size = Math.SQRT1_2 * radius;\n        ctx.rect(x - size, y - size, 2 * size, 2 * size);\n        break;\n      }\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'rectRot':\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + yOffset, y - xOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      ctx.lineTo(x - yOffset, y + xOffset);\n      ctx.closePath();\n      break;\n    case 'crossRot':\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'cross':\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      ctx.moveTo(x + yOffset, y - xOffset);\n      ctx.lineTo(x - yOffset, y + xOffset);\n      break;\n    case 'star':\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      ctx.moveTo(x + yOffset, y - xOffset);\n      ctx.lineTo(x - yOffset, y + xOffset);\n      rad += QUARTER_PI;\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      ctx.moveTo(x + yOffset, y - xOffset);\n      ctx.lineTo(x - yOffset, y + xOffset);\n      break;\n    case 'line':\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      break;\n    case 'dash':\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n      break;\n  }\n  ctx.fill();\n}\nfunction calculateLabelSize(ctx, lines, fonts, strokeWidth) {\n  ctx.save();\n  const count = lines.length;\n  let width = 0;\n  let height = strokeWidth;\n  for (let i = 0; i < count; i++) {\n    const font = fonts[Math.min(i, fonts.length - 1)];\n    ctx.font = font.string;\n    const text = lines[i];\n    width = Math.max(width, ctx.measureText(text).width + strokeWidth);\n    height += font.lineHeight;\n  }\n  ctx.restore();\n  return {\n    width,\n    height\n  };\n}\nfunction applyLabelDecoration(ctx, _ref8, labels, fonts) {\n  let {\n    x,\n    y\n  } = _ref8;\n  ctx.beginPath();\n  let lhs = 0;\n  labels.forEach(function (l, i) {\n    const f = fonts[Math.min(i, fonts.length - 1)];\n    const lh = f.lineHeight;\n    ctx.font = f.string;\n    ctx.strokeText(l, x, y + lh / 2 + lhs);\n    lhs += lh;\n  });\n  ctx.stroke();\n}\nfunction applyLabelContent(ctx, _ref9, labels, _ref10) {\n  let {\n    x,\n    y\n  } = _ref9;\n  let {\n    fonts,\n    colors\n  } = _ref10;\n  let lhs = 0;\n  labels.forEach(function (l, i) {\n    const c = colors[Math.min(i, colors.length - 1)];\n    const f = fonts[Math.min(i, fonts.length - 1)];\n    const lh = f.lineHeight;\n    ctx.beginPath();\n    ctx.font = f.string;\n    ctx.fillStyle = c;\n    ctx.fillText(l, x, y + lh / 2 + lhs);\n    lhs += lh;\n    ctx.fill();\n  });\n}\nfunction getOpacity(value, elementValue) {\n  const opacity = isNumber(value) ? value : elementValue;\n  return isNumber(opacity) ? clamp(opacity, 0, 1) : 1;\n}\nconst positions = ['left', 'bottom', 'top', 'right'];\n\n/**\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */\n\n/**\n * Drawa the callout component for labels.\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {AnnotationElement} element - the label element\n */\nfunction drawCallout(ctx, element) {\n  const {\n    pointX,\n    pointY,\n    options\n  } = element;\n  const callout = options.callout;\n  const calloutPosition = callout && callout.display && resolveCalloutPosition(element, callout);\n  if (!calloutPosition || isPointInRange(element, callout, calloutPosition)) {\n    return;\n  }\n  ctx.save();\n  ctx.beginPath();\n  const stroke = setBorderStyle(ctx, callout);\n  if (!stroke) {\n    return ctx.restore();\n  }\n  const {\n    separatorStart,\n    separatorEnd\n  } = getCalloutSeparatorCoord(element, calloutPosition);\n  const {\n    sideStart,\n    sideEnd\n  } = getCalloutSideCoord(element, calloutPosition, separatorStart);\n  if (callout.margin > 0 || options.borderWidth === 0) {\n    ctx.moveTo(separatorStart.x, separatorStart.y);\n    ctx.lineTo(separatorEnd.x, separatorEnd.y);\n  }\n  ctx.moveTo(sideStart.x, sideStart.y);\n  ctx.lineTo(sideEnd.x, sideEnd.y);\n  const rotatedPoint = rotated({\n    x: pointX,\n    y: pointY\n  }, element.getCenterPoint(), toRadians(-element.rotation));\n  ctx.lineTo(rotatedPoint.x, rotatedPoint.y);\n  ctx.stroke();\n  ctx.restore();\n}\nfunction getCalloutSeparatorCoord(element, position) {\n  const {\n    x,\n    y,\n    x2,\n    y2\n  } = element;\n  const adjust = getCalloutSeparatorAdjust(element, position);\n  let separatorStart, separatorEnd;\n  if (position === 'left' || position === 'right') {\n    separatorStart = {\n      x: x + adjust,\n      y\n    };\n    separatorEnd = {\n      x: separatorStart.x,\n      y: y2\n    };\n  } else {\n    //  position 'top' or 'bottom'\n    separatorStart = {\n      x,\n      y: y + adjust\n    };\n    separatorEnd = {\n      x: x2,\n      y: separatorStart.y\n    };\n  }\n  return {\n    separatorStart,\n    separatorEnd\n  };\n}\nfunction getCalloutSeparatorAdjust(element, position) {\n  const {\n    width,\n    height,\n    options\n  } = element;\n  const adjust = options.callout.margin + options.borderWidth / 2;\n  if (position === 'right') {\n    return width + adjust;\n  } else if (position === 'bottom') {\n    return height + adjust;\n  }\n  return -adjust;\n}\nfunction getCalloutSideCoord(element, position, separatorStart) {\n  const {\n    y,\n    width,\n    height,\n    options\n  } = element;\n  const start = options.callout.start;\n  const side = getCalloutSideAdjust(position, options.callout);\n  let sideStart, sideEnd;\n  if (position === 'left' || position === 'right') {\n    sideStart = {\n      x: separatorStart.x,\n      y: y + getSize(height, start)\n    };\n    sideEnd = {\n      x: sideStart.x + side,\n      y: sideStart.y\n    };\n  } else {\n    //  position 'top' or 'bottom'\n    sideStart = {\n      x: separatorStart.x + getSize(width, start),\n      y: separatorStart.y\n    };\n    sideEnd = {\n      x: sideStart.x,\n      y: sideStart.y + side\n    };\n  }\n  return {\n    sideStart,\n    sideEnd\n  };\n}\nfunction getCalloutSideAdjust(position, options) {\n  const side = options.side;\n  if (position === 'left' || position === 'top') {\n    return -side;\n  }\n  return side;\n}\nfunction resolveCalloutPosition(element, options) {\n  const position = options.position;\n  if (positions.includes(position)) {\n    return position;\n  }\n  return resolveCalloutAutoPosition(element, options);\n}\nfunction resolveCalloutAutoPosition(element, options) {\n  const {\n    x,\n    y,\n    x2,\n    y2,\n    width,\n    height,\n    pointX,\n    pointY,\n    centerX,\n    centerY,\n    rotation\n  } = element;\n  const center = {\n    x: centerX,\n    y: centerY\n  };\n  const start = options.start;\n  const xAdjust = getSize(width, start);\n  const yAdjust = getSize(height, start);\n  const xPoints = [x, x + xAdjust, x + xAdjust, x2];\n  const yPoints = [y + yAdjust, y2, y, y2];\n  const result = [];\n  for (let index = 0; index < 4; index++) {\n    const rotatedPoint = rotated({\n      x: xPoints[index],\n      y: yPoints[index]\n    }, center, toRadians(rotation));\n    result.push({\n      position: positions[index],\n      distance: distanceBetweenPoints(rotatedPoint, {\n        x: pointX,\n        y: pointY\n      })\n    });\n  }\n  return result.sort((a, b) => a.distance - b.distance)[0].position;\n}\nfunction isPointInRange(element, callout, position) {\n  const {\n    pointX,\n    pointY\n  } = element;\n  const margin = callout.margin;\n  let x = pointX;\n  let y = pointY;\n  if (position === 'left') {\n    x += margin;\n  } else if (position === 'right') {\n    x -= margin;\n  } else if (position === 'top') {\n    y += margin;\n  } else if (position === 'bottom') {\n    y -= margin;\n  }\n  return element.inRange(x, y);\n}\nconst limitedLineScale = {\n  xScaleID: {\n    min: 'xMin',\n    max: 'xMax',\n    start: 'left',\n    end: 'right',\n    startProp: 'x',\n    endProp: 'x2'\n  },\n  yScaleID: {\n    min: 'yMin',\n    max: 'yMax',\n    start: 'bottom',\n    end: 'top',\n    startProp: 'y',\n    endProp: 'y2'\n  }\n};\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import(\"chart.js\").Scale } Scale\n * @typedef { import(\"chart.js\").Point } Point\n * @typedef { import('../../types/element').AnnotationBoxModel } AnnotationBoxModel\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\n * @typedef { import('../../types/options').LineAnnotationOptions } LineAnnotationOptions\n * @typedef { import('../../types/options').PointAnnotationOptions } PointAnnotationOptions\n * @typedef { import('../../types/options').PolygonAnnotationOptions } PolygonAnnotationOptions\n */\n\n/**\n * @param {Scale} scale\n * @param {number|string} value\n * @param {number} fallback\n * @returns {number}\n */\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ? scale.getPixelForValue(value) : fallback;\n}\n\n/**\n * Search the scale defined in chartjs by the axis related to the annotation options key.\n * @param {{ [key: string]: Scale }} scales\n * @param {CoreAnnotationOptions} options\n * @param {string} key\n * @returns {string}\n */\nfunction retrieveScaleID(scales, options, key) {\n  const scaleID = options[key];\n  if (scaleID || key === 'scaleID') {\n    return scaleID;\n  }\n  const axis = key.charAt(0);\n  const axes = Object.values(scales).filter(scale => scale.axis && scale.axis === axis);\n  if (axes.length) {\n    return axes[0].id;\n  }\n  return axis;\n}\n\n/**\n * @param {Scale} scale\n * @param {{min: number, max: number, start: number, end: number}} options\n * @returns {{start: number, end: number}|undefined}\n */\nfunction getDimensionByScale(scale, options) {\n  if (scale) {\n    const reverse = scale.options.reverse;\n    const start = scaleValue(scale, options.min, reverse ? options.end : options.start);\n    const end = scaleValue(scale, options.max, reverse ? options.start : options.end);\n    return {\n      start,\n      end\n    };\n  }\n}\n\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @returns {Point}\n */\nfunction getChartPoint(chart, options) {\n  const {\n    chartArea,\n    scales\n  } = chart;\n  const xScale = scales[retrieveScaleID(scales, options, 'xScaleID')];\n  const yScale = scales[retrieveScaleID(scales, options, 'yScaleID')];\n  let x = chartArea.width / 2;\n  let y = chartArea.height / 2;\n  if (xScale) {\n    x = scaleValue(xScale, options.xValue, xScale.left + xScale.width / 2);\n  }\n  if (yScale) {\n    y = scaleValue(yScale, options.yValue, yScale.top + yScale.height / 2);\n  }\n  return {\n    x,\n    y\n  };\n}\n\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @returns {AnnotationBoxModel}\n */\nfunction resolveBoxProperties(chart, options) {\n  const scales = chart.scales;\n  const xScale = scales[retrieveScaleID(scales, options, 'xScaleID')];\n  const yScale = scales[retrieveScaleID(scales, options, 'yScaleID')];\n  if (!xScale && !yScale) {\n    return {};\n  }\n  let {\n    left: x,\n    right: x2\n  } = xScale || chart.chartArea;\n  let {\n    top: y,\n    bottom: y2\n  } = yScale || chart.chartArea;\n  const xDim = getChartDimensionByScale(xScale, {\n    min: options.xMin,\n    max: options.xMax,\n    start: x,\n    end: x2\n  });\n  x = xDim.start;\n  x2 = xDim.end;\n  const yDim = getChartDimensionByScale(yScale, {\n    min: options.yMin,\n    max: options.yMax,\n    start: y2,\n    end: y\n  });\n  y = yDim.start;\n  y2 = yDim.end;\n  return {\n    x,\n    y,\n    x2,\n    y2,\n    width: x2 - x,\n    height: y2 - y,\n    centerX: x + (x2 - x) / 2,\n    centerY: y + (y2 - y) / 2\n  };\n}\n\n/**\n * @param {Chart} chart\n * @param {PointAnnotationOptions|PolygonAnnotationOptions} options\n * @returns {AnnotationBoxModel}\n */\nfunction resolvePointProperties(chart, options) {\n  if (!isBoundToPoint(options)) {\n    const box = resolveBoxProperties(chart, options);\n    let radius = options.radius;\n    if (!radius || isNaN(radius)) {\n      radius = Math.min(box.width, box.height) / 2;\n      options.radius = radius;\n    }\n    const size = radius * 2;\n    const adjustCenterX = box.centerX + options.xAdjust;\n    const adjustCenterY = box.centerY + options.yAdjust;\n    return {\n      x: adjustCenterX - radius,\n      y: adjustCenterY - radius,\n      x2: adjustCenterX + radius,\n      y2: adjustCenterY + radius,\n      centerX: adjustCenterX,\n      centerY: adjustCenterY,\n      width: size,\n      height: size,\n      radius\n    };\n  }\n  return getChartCircle(chart, options);\n}\n/**\n * @param {Chart} chart\n * @param {LineAnnotationOptions} options\n * @returns {AnnotationBoxModel}\n */\nfunction resolveLineProperties(chart, options) {\n  const {\n    scales,\n    chartArea\n  } = chart;\n  const scale = scales[options.scaleID];\n  const area = {\n    x: chartArea.left,\n    y: chartArea.top,\n    x2: chartArea.right,\n    y2: chartArea.bottom\n  };\n  if (scale) {\n    resolveFullLineProperties(scale, area, options);\n  } else {\n    resolveLimitedLineProperties(scales, area, options);\n  }\n  return area;\n}\n\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @param {boolean} [centerBased=false]\n * @returns {AnnotationBoxModel}\n */\nfunction resolveBoxAndLabelProperties(chart, options) {\n  const properties = resolveBoxProperties(chart, options);\n  properties.initProperties = initAnimationProperties(chart, properties, options);\n  properties.elements = [{\n    type: 'label',\n    optionScope: 'label',\n    properties: resolveLabelElementProperties$1(chart, properties, options),\n    initProperties: properties.initProperties\n  }];\n  return properties;\n}\nfunction getChartCircle(chart, options) {\n  const point = getChartPoint(chart, options);\n  const size = options.radius * 2;\n  return {\n    x: point.x - options.radius + options.xAdjust,\n    y: point.y - options.radius + options.yAdjust,\n    x2: point.x + options.radius + options.xAdjust,\n    y2: point.y + options.radius + options.yAdjust,\n    centerX: point.x + options.xAdjust,\n    centerY: point.y + options.yAdjust,\n    radius: options.radius,\n    width: size,\n    height: size\n  };\n}\nfunction getChartDimensionByScale(scale, options) {\n  const result = getDimensionByScale(scale, options) || options;\n  return {\n    start: Math.min(result.start, result.end),\n    end: Math.max(result.start, result.end)\n  };\n}\nfunction resolveFullLineProperties(scale, area, options) {\n  const min = scaleValue(scale, options.value, NaN);\n  const max = scaleValue(scale, options.endValue, min);\n  if (scale.isHorizontal()) {\n    area.x = min;\n    area.x2 = max;\n  } else {\n    area.y = min;\n    area.y2 = max;\n  }\n}\nfunction resolveLimitedLineProperties(scales, area, options) {\n  for (const scaleId of Object.keys(limitedLineScale)) {\n    const scale = scales[retrieveScaleID(scales, options, scaleId)];\n    if (scale) {\n      const {\n        min,\n        max,\n        start,\n        end,\n        startProp,\n        endProp\n      } = limitedLineScale[scaleId];\n      const dim = getDimensionByScale(scale, {\n        min: options[min],\n        max: options[max],\n        start: scale[start],\n        end: scale[end]\n      });\n      area[startProp] = dim.start;\n      area[endProp] = dim.end;\n    }\n  }\n}\nfunction calculateX(_ref11, labelSize, position, padding) {\n  let {\n    properties,\n    options\n  } = _ref11;\n  const {\n    x: start,\n    x2: end,\n    width: size\n  } = properties;\n  return calculatePosition({\n    start,\n    end,\n    size,\n    borderWidth: options.borderWidth\n  }, {\n    position: position.x,\n    padding: {\n      start: padding.left,\n      end: padding.right\n    },\n    adjust: options.label.xAdjust,\n    size: labelSize.width\n  });\n}\nfunction calculateY(_ref12, labelSize, position, padding) {\n  let {\n    properties,\n    options\n  } = _ref12;\n  const {\n    y: start,\n    y2: end,\n    height: size\n  } = properties;\n  return calculatePosition({\n    start,\n    end,\n    size,\n    borderWidth: options.borderWidth\n  }, {\n    position: position.y,\n    padding: {\n      start: padding.top,\n      end: padding.bottom\n    },\n    adjust: options.label.yAdjust,\n    size: labelSize.height\n  });\n}\nfunction calculatePosition(boxOpts, labelOpts) {\n  const {\n    start,\n    end,\n    borderWidth\n  } = boxOpts;\n  const {\n    position,\n    padding: {\n      start: padStart,\n      end: padEnd\n    },\n    adjust\n  } = labelOpts;\n  const availableSize = end - borderWidth - start - padStart - padEnd - labelOpts.size;\n  return start + borderWidth / 2 + adjust + getRelativePosition(availableSize, position);\n}\nfunction resolveLabelElementProperties$1(chart, properties, options) {\n  const label = options.label;\n  label.backgroundColor = 'transparent';\n  label.callout.display = false;\n  const position = toPosition(label.position);\n  const padding = toPadding(label.padding);\n  const labelSize = measureLabelSize(chart.ctx, label);\n  const x = calculateX({\n    properties,\n    options\n  }, labelSize, position, padding);\n  const y = calculateY({\n    properties,\n    options\n  }, labelSize, position, padding);\n  const width = labelSize.width + padding.width;\n  const height = labelSize.height + padding.height;\n  return {\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n    width,\n    height,\n    centerX: x + width / 2,\n    centerY: y + height / 2,\n    rotation: label.rotation\n  };\n}\nconst moveHooks = ['enter', 'leave'];\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\n */\n\nconst eventHooks = moveHooks.concat('click');\n\n/**\n * @param {Chart} chart\n * @param {Object} state\n * @param {AnnotationPluginOptions} options\n */\nfunction updateListeners(chart, state, options) {\n  state.listened = loadHooks(options, eventHooks, state.listeners);\n  state.moveListened = false;\n  moveHooks.forEach(hook => {\n    if (isFunction(options[hook])) {\n      state.moveListened = true;\n    }\n  });\n  if (!state.listened || !state.moveListened) {\n    state.annotations.forEach(scope => {\n      if (!state.listened && isFunction(scope.click)) {\n        state.listened = true;\n      }\n      if (!state.moveListened) {\n        moveHooks.forEach(hook => {\n          if (isFunction(scope[hook])) {\n            state.listened = true;\n            state.moveListened = true;\n          }\n        });\n      }\n    });\n  }\n}\n\n/**\n * @param {Object} state\n * @param {ChartEvent} event\n * @param {AnnotationPluginOptions} options\n * @return {boolean|undefined}\n */\nfunction handleEvent(state, event, options) {\n  if (state.listened) {\n    switch (event.type) {\n      case 'mousemove':\n      case 'mouseout':\n        return handleMoveEvents(state, event, options);\n      case 'click':\n        return handleClickEvents(state, event, options);\n    }\n  }\n}\nfunction handleMoveEvents(state, event, options) {\n  if (!state.moveListened) {\n    return;\n  }\n  let elements;\n  if (event.type === 'mousemove') {\n    elements = getElements(state.visibleElements, event, options.interaction);\n  } else {\n    elements = [];\n  }\n  const previous = state.hovered;\n  state.hovered = elements;\n  const context = {\n    state,\n    event\n  };\n  let changed = dispatchMoveEvents(context, 'leave', previous, elements);\n  return dispatchMoveEvents(context, 'enter', elements, previous) || changed;\n}\nfunction dispatchMoveEvents(_ref13, hook, elements, checkElements) {\n  let {\n    state,\n    event\n  } = _ref13;\n  let changed;\n  for (const element of elements) {\n    if (checkElements.indexOf(element) < 0) {\n      changed = dispatchEvent(element.options[hook] || state.listeners[hook], element, event) || changed;\n    }\n  }\n  return changed;\n}\nfunction handleClickEvents(state, event, options) {\n  const listeners = state.listeners;\n  const elements = getElements(state.visibleElements, event, options.interaction);\n  let changed;\n  for (const element of elements) {\n    changed = dispatchEvent(element.options.click || listeners.click, element, event) || changed;\n  }\n  return changed;\n}\nfunction dispatchEvent(handler, element, event) {\n  return callback(handler, [element.$context, event]) === true;\n}\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */\n\nconst elementHooks = ['afterDraw', 'beforeDraw'];\n\n/**\n * @param {Chart} chart\n * @param {Object} state\n * @param {AnnotationPluginOptions} options\n */\nfunction updateHooks(chart, state, options) {\n  const visibleElements = state.visibleElements;\n  state.hooked = loadHooks(options, elementHooks, state.hooks);\n  if (!state.hooked) {\n    visibleElements.forEach(scope => {\n      if (!state.hooked) {\n        elementHooks.forEach(hook => {\n          if (isFunction(scope.options[hook])) {\n            state.hooked = true;\n          }\n        });\n      }\n    });\n  }\n}\n\n/**\n * @param {Object} state\n * @param {AnnotationElement} element\n * @param {string} hook\n */\nfunction invokeHook(state, element, hook) {\n  if (state.hooked) {\n    const callbackHook = element.options[hook] || state.hooks[hook];\n    return callback(callbackHook, [element.$context]);\n  }\n}\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import(\"chart.js\").Scale } Scale\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\n */\n\n/**\n * @param {Chart} chart\n * @param {Scale} scale\n * @param {CoreAnnotationOptions[]} annotations\n */\nfunction adjustScaleRange(chart, scale, annotations) {\n  const range = getScaleLimits(chart.scales, scale, annotations);\n  let changed = changeScaleLimit(scale, range, 'min', 'suggestedMin');\n  changed = changeScaleLimit(scale, range, 'max', 'suggestedMax') || changed;\n  if (changed && isFunction(scale.handleTickRangeOptions)) {\n    scale.handleTickRangeOptions();\n  }\n}\n\n/**\n * @param {CoreAnnotationOptions[]} annotations\n * @param {{ [key: string]: Scale }} scales\n */\nfunction verifyScaleOptions(annotations, scales) {\n  for (const annotation of annotations) {\n    verifyScaleIDs(annotation, scales);\n  }\n}\nfunction changeScaleLimit(scale, range, limit, suggestedLimit) {\n  if (isFinite(range[limit]) && !scaleLimitDefined(scale.options, limit, suggestedLimit)) {\n    const changed = scale[limit] !== range[limit];\n    scale[limit] = range[limit];\n    return changed;\n  }\n}\nfunction scaleLimitDefined(scaleOptions, limit, suggestedLimit) {\n  return defined(scaleOptions[limit]) || defined(scaleOptions[suggestedLimit]);\n}\nfunction verifyScaleIDs(annotation, scales) {\n  for (const key of ['scaleID', 'xScaleID', 'yScaleID']) {\n    const scaleID = retrieveScaleID(scales, annotation, key);\n    if (scaleID && !scales[scaleID] && verifyProperties(annotation, key)) {\n      console.warn(\"No scale found with id '\".concat(scaleID, \"' for annotation '\").concat(annotation.id, \"'\"));\n    }\n  }\n}\nfunction verifyProperties(annotation, key) {\n  if (key === 'scaleID') {\n    return true;\n  }\n  const axis = key.charAt(0);\n  for (const prop of ['Min', 'Max', 'Value']) {\n    if (defined(annotation[axis + prop])) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getScaleLimits(scales, scale, annotations) {\n  const axis = scale.axis;\n  const scaleID = scale.id;\n  const scaleIDOption = axis + 'ScaleID';\n  const limits = {\n    min: valueOrDefault(scale.min, Number.NEGATIVE_INFINITY),\n    max: valueOrDefault(scale.max, Number.POSITIVE_INFINITY)\n  };\n  for (const annotation of annotations) {\n    if (annotation.scaleID === scaleID) {\n      updateLimits(annotation, scale, ['value', 'endValue'], limits);\n    } else if (retrieveScaleID(scales, annotation, scaleIDOption) === scaleID) {\n      updateLimits(annotation, scale, [axis + 'Min', axis + 'Max', axis + 'Value'], limits);\n    }\n  }\n  return limits;\n}\nfunction updateLimits(annotation, scale, props, limits) {\n  for (const prop of props) {\n    const raw = annotation[prop];\n    if (defined(raw)) {\n      const value = scale.parse(raw);\n      limits.min = Math.min(limits.min, value);\n      limits.max = Math.max(limits.max, value);\n    }\n  }\n}\nclass BoxAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const {\n      x,\n      y\n    } = rotated({\n      x: mouseX,\n      y: mouseY\n    }, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));\n    return inBoxRange({\n      x,\n      y\n    }, this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis, this.options);\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), this.options.rotation);\n    drawBox(ctx, this, this.options);\n    ctx.restore();\n  }\n  get label() {\n    return this.elements && this.elements[0];\n  }\n  resolveElementProperties(chart, options) {\n    return resolveBoxAndLabelProperties(chart, options);\n  }\n}\nBoxAnnotation.id = 'boxAnnotation';\nBoxAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderRadius: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  init: undefined,\n  hitTolerance: 0,\n  label: {\n    backgroundColor: 'transparent',\n    borderWidth: 0,\n    callout: {\n      display: false\n    },\n    color: 'black',\n    content: null,\n    display: false,\n    drawTime: undefined,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    height: undefined,\n    hitTolerance: undefined,\n    opacity: undefined,\n    padding: 6,\n    position: 'center',\n    rotation: undefined,\n    textAlign: 'start',\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    width: undefined,\n    xAdjust: 0,\n    yAdjust: 0,\n    z: undefined\n  },\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\nBoxAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nBoxAnnotation.descriptors = {\n  label: {\n    _fallback: true\n  }\n};\nclass DoughnutLabelAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    return inLabelRange({\n      x: mouseX,\n      y: mouseY\n    }, {\n      rect: this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition),\n      center: this.getCenterPoint(useFinalPosition)\n    }, axis, {\n      rotation: this.rotation,\n      borderWidth: 0,\n      hitTolerance: this.options.hitTolerance\n    });\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    const options = this.options;\n    if (!options.display || !options.content) {\n      return;\n    }\n    drawBackground(ctx, this);\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), this.rotation);\n    drawLabel(ctx, this, options, this._fitRatio);\n    ctx.restore();\n  }\n  resolveElementProperties(chart, options) {\n    const meta = getDatasetMeta(chart, options);\n    if (!meta) {\n      return {};\n    }\n    const {\n      controllerMeta,\n      point,\n      radius\n    } = getControllerMeta(chart, options, meta);\n    let labelSize = measureLabelSize(chart.ctx, options);\n    const _fitRatio = getFitRatio(labelSize, radius);\n    if (shouldFit(options, _fitRatio)) {\n      labelSize = {\n        width: labelSize.width * _fitRatio,\n        height: labelSize.height * _fitRatio\n      };\n    }\n    const {\n      position,\n      xAdjust,\n      yAdjust\n    } = options;\n    const boxSize = measureLabelRectangle(point, labelSize, {\n      borderWidth: 0,\n      position,\n      xAdjust,\n      yAdjust\n    });\n    return _objectSpread(_objectSpread(_objectSpread({\n      initProperties: initAnimationProperties(chart, boxSize, options)\n    }, boxSize), controllerMeta), {}, {\n      rotation: options.rotation,\n      _fitRatio\n    });\n  }\n}\nDoughnutLabelAnnotation.id = 'doughnutLabelAnnotation';\nDoughnutLabelAnnotation.defaults = {\n  autoFit: true,\n  autoHide: true,\n  backgroundColor: 'transparent',\n  backgroundShadowColor: 'transparent',\n  borderColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderShadowColor: 'transparent',\n  borderWidth: 0,\n  color: 'black',\n  content: null,\n  display: true,\n  font: {\n    family: undefined,\n    lineHeight: undefined,\n    size: undefined,\n    style: undefined,\n    weight: undefined\n  },\n  height: undefined,\n  hitTolerance: 0,\n  init: undefined,\n  opacity: undefined,\n  position: 'center',\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  spacing: 1,\n  textAlign: 'center',\n  textStrokeColor: undefined,\n  textStrokeWidth: 0,\n  width: undefined,\n  xAdjust: 0,\n  yAdjust: 0\n};\nDoughnutLabelAnnotation.defaultRoutes = {};\nfunction getDatasetMeta(chart, options) {\n  return chart.getSortedVisibleDatasetMetas().reduce(function (result, value) {\n    const controller = value.controller;\n    if (controller instanceof DoughnutController && isControllerVisible(chart, options, value.data) && (!result || controller.innerRadius < result.controller.innerRadius) && controller.options.circumference >= 90) {\n      return value;\n    }\n    return result;\n  }, undefined);\n}\nfunction isControllerVisible(chart, options, elements) {\n  if (!options.autoHide) {\n    return true;\n  }\n  for (let i = 0; i < elements.length; i++) {\n    if (!elements[i].hidden && chart.getDataVisibility(i)) {\n      return true;\n    }\n  }\n}\nfunction getControllerMeta(_ref14, options, meta) {\n  let {\n    chartArea\n  } = _ref14;\n  const {\n    left,\n    top,\n    right,\n    bottom\n  } = chartArea;\n  const {\n    innerRadius,\n    offsetX,\n    offsetY\n  } = meta.controller;\n  const x = (left + right) / 2 + offsetX;\n  const y = (top + bottom) / 2 + offsetY;\n  const square = {\n    left: Math.max(x - innerRadius, left),\n    right: Math.min(x + innerRadius, right),\n    top: Math.max(y - innerRadius, top),\n    bottom: Math.min(y + innerRadius, bottom)\n  };\n  const point = {\n    x: (square.left + square.right) / 2,\n    y: (square.top + square.bottom) / 2\n  };\n  const space = options.spacing + options.borderWidth / 2;\n  const _radius = innerRadius - space;\n  const _counterclockwise = point.y > y;\n  const side = _counterclockwise ? top + space : bottom - space;\n  const angles = getAngles(side, x, y, _radius);\n  const controllerMeta = _objectSpread({\n    _centerX: x,\n    _centerY: y,\n    _radius,\n    _counterclockwise\n  }, angles);\n  return {\n    controllerMeta,\n    point,\n    radius: Math.min(innerRadius, Math.min(square.right - square.left, square.bottom - square.top) / 2)\n  };\n}\nfunction getFitRatio(_ref15, radius) {\n  let {\n    width,\n    height\n  } = _ref15;\n  const hypo = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\n  return radius * 2 / hypo;\n}\nfunction getAngles(y, centerX, centerY, radius) {\n  const yk2 = Math.pow(centerY - y, 2);\n  const r2 = Math.pow(radius, 2);\n  const b = centerX * -2;\n  const c = Math.pow(centerX, 2) + yk2 - r2;\n  const delta = Math.pow(b, 2) - 4 * c;\n  if (delta <= 0) {\n    return {\n      _startAngle: 0,\n      _endAngle: TAU\n    };\n  }\n  const start = (-b - Math.sqrt(delta)) / 2;\n  const end = (-b + Math.sqrt(delta)) / 2;\n  return {\n    _startAngle: getAngleFromPoint({\n      x: centerX,\n      y: centerY\n    }, {\n      x: start,\n      y\n    }).angle,\n    _endAngle: getAngleFromPoint({\n      x: centerX,\n      y: centerY\n    }, {\n      x: end,\n      y\n    }).angle\n  };\n}\nfunction drawBackground(ctx, element) {\n  const {\n    _centerX,\n    _centerY,\n    _radius,\n    _startAngle,\n    _endAngle,\n    _counterclockwise,\n    options\n  } = element;\n  ctx.save();\n  const stroke = setBorderStyle(ctx, options);\n  ctx.fillStyle = options.backgroundColor;\n  ctx.beginPath();\n  ctx.arc(_centerX, _centerY, _radius, _startAngle, _endAngle, _counterclockwise);\n  ctx.closePath();\n  ctx.fill();\n  if (stroke) {\n    ctx.stroke();\n  }\n  ctx.restore();\n}\nclass LabelAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    return inLabelRange({\n      x: mouseX,\n      y: mouseY\n    }, {\n      rect: this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition),\n      center: this.getCenterPoint(useFinalPosition)\n    }, axis, {\n      rotation: this.rotation,\n      borderWidth: this.options.borderWidth,\n      hitTolerance: this.options.hitTolerance\n    });\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    const options = this.options;\n    const visible = !defined(this._visible) || this._visible;\n    if (!options.display || !options.content || !visible) {\n      return;\n    }\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), this.rotation);\n    drawCallout(ctx, this);\n    drawBox(ctx, this, options);\n    drawLabel(ctx, getLabelSize(this), options);\n    ctx.restore();\n  }\n  resolveElementProperties(chart, options) {\n    let point;\n    if (!isBoundToPoint(options)) {\n      const {\n        centerX,\n        centerY\n      } = resolveBoxProperties(chart, options);\n      point = {\n        x: centerX,\n        y: centerY\n      };\n    } else {\n      point = getChartPoint(chart, options);\n    }\n    const padding = toPadding(options.padding);\n    const labelSize = measureLabelSize(chart.ctx, options);\n    const boxSize = measureLabelRectangle(point, labelSize, options, padding);\n    return _objectSpread(_objectSpread({\n      initProperties: initAnimationProperties(chart, boxSize, options),\n      pointX: point.x,\n      pointY: point.y\n    }, boxSize), {}, {\n      rotation: options.rotation\n    });\n  }\n}\nLabelAnnotation.id = 'labelAnnotation';\nLabelAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundColor: 'transparent',\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderRadius: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 0,\n  callout: {\n    borderCapStyle: 'butt',\n    borderColor: undefined,\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderWidth: 1,\n    display: false,\n    margin: 5,\n    position: 'auto',\n    side: 5,\n    start: '50%'\n  },\n  color: 'black',\n  content: null,\n  display: true,\n  font: {\n    family: undefined,\n    lineHeight: undefined,\n    size: undefined,\n    style: undefined,\n    weight: undefined\n  },\n  height: undefined,\n  hitTolerance: 0,\n  init: undefined,\n  opacity: undefined,\n  padding: 6,\n  position: 'center',\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  textAlign: 'center',\n  textStrokeColor: undefined,\n  textStrokeWidth: 0,\n  width: undefined,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\nLabelAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\nfunction getLabelSize(_ref16) {\n  let {\n    x,\n    y,\n    width,\n    height,\n    options\n  } = _ref16;\n  const hBorderWidth = options.borderWidth / 2;\n  const padding = toPadding(options.padding);\n  return {\n    x: x + padding.left + hBorderWidth,\n    y: y + padding.top + hBorderWidth,\n    width: width - padding.left - padding.right - options.borderWidth,\n    height: height - padding.top - padding.bottom - options.borderWidth\n  };\n}\nconst pointInLine = (p1, p2, t) => ({\n  x: p1.x + t * (p2.x - p1.x),\n  y: p1.y + t * (p2.y - p1.y)\n});\nconst interpolateX = (y, p1, p2) => pointInLine(p1, p2, Math.abs((y - p1.y) / (p2.y - p1.y))).x;\nconst interpolateY = (x, p1, p2) => pointInLine(p1, p2, Math.abs((x - p1.x) / (p2.x - p1.x))).y;\nconst sqr = v => v * v;\nconst rangeLimit = (mouseX, mouseY, _ref17, axis) => {\n  let {\n    x,\n    y,\n    x2,\n    y2\n  } = _ref17;\n  return axis === 'y' ? {\n    start: Math.min(y, y2),\n    end: Math.max(y, y2),\n    value: mouseY\n  } : {\n    start: Math.min(x, x2),\n    end: Math.max(x, x2),\n    value: mouseX\n  };\n};\n// http://www.independent-software.com/determining-coordinates-on-a-html-canvas-bezier-curve.html\nconst coordInCurve = (start, cp, end, t) => (1 - t) * (1 - t) * start + 2 * (1 - t) * t * cp + t * t * end;\nconst pointInCurve = (start, cp, end, t) => ({\n  x: coordInCurve(start.x, cp.x, end.x, t),\n  y: coordInCurve(start.y, cp.y, end.y, t)\n});\nconst coordAngleInCurve = (start, cp, end, t) => 2 * (1 - t) * (cp - start) + 2 * t * (end - cp);\nconst angleInCurve = (start, cp, end, t) => -Math.atan2(coordAngleInCurve(start.x, cp.x, end.x, t), coordAngleInCurve(start.y, cp.y, end.y, t)) + 0.5 * PI;\nclass LineAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const hitSize = (this.options.borderWidth + this.options.hitTolerance) / 2;\n    if (axis !== 'x' && axis !== 'y') {\n      const point = {\n        mouseX,\n        mouseY\n      };\n      const {\n        path,\n        ctx\n      } = this;\n      if (path) {\n        setBorderStyle(ctx, this.options);\n        ctx.lineWidth += this.options.hitTolerance;\n        const {\n          chart\n        } = this.$context;\n        const mx = mouseX * chart.currentDevicePixelRatio;\n        const my = mouseY * chart.currentDevicePixelRatio;\n        const result = ctx.isPointInStroke(path, mx, my) || isOnLabel(this, point, useFinalPosition);\n        ctx.restore();\n        return result;\n      }\n      const epsilon = sqr(hitSize);\n      return intersects(this, point, epsilon, useFinalPosition) || isOnLabel(this, point, useFinalPosition);\n    }\n    return inAxisRange(this, {\n      mouseX,\n      mouseY\n    }, axis, {\n      hitSize,\n      useFinalPosition\n    });\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    const {\n      x,\n      y,\n      x2,\n      y2,\n      cp,\n      options\n    } = this;\n    ctx.save();\n    if (!setBorderStyle(ctx, options)) {\n      // no border width, then line is not drawn\n      return ctx.restore();\n    }\n    setShadowStyle(ctx, options);\n    const length = Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2));\n    if (options.curve && cp) {\n      drawCurve(ctx, this, cp, length);\n      return ctx.restore();\n    }\n    const {\n      startOpts,\n      endOpts,\n      startAdjust,\n      endAdjust\n    } = getArrowHeads(this);\n    const angle = Math.atan2(y2 - y, x2 - x);\n    ctx.translate(x, y);\n    ctx.rotate(angle);\n    ctx.beginPath();\n    ctx.moveTo(0 + startAdjust, 0);\n    ctx.lineTo(length - endAdjust, 0);\n    ctx.shadowColor = options.borderShadowColor;\n    ctx.stroke();\n    drawArrowHead(ctx, 0, startAdjust, startOpts);\n    drawArrowHead(ctx, length, -endAdjust, endOpts);\n    ctx.restore();\n  }\n  get label() {\n    return this.elements && this.elements[0];\n  }\n  resolveElementProperties(chart, options) {\n    const area = resolveLineProperties(chart, options);\n    const {\n      x,\n      y,\n      x2,\n      y2\n    } = area;\n    const inside = isLineInArea(area, chart.chartArea);\n    const properties = inside ? limitLineToArea({\n      x,\n      y\n    }, {\n      x: x2,\n      y: y2\n    }, chart.chartArea) : {\n      x,\n      y,\n      x2,\n      y2,\n      width: Math.abs(x2 - x),\n      height: Math.abs(y2 - y)\n    };\n    properties.centerX = (x2 + x) / 2;\n    properties.centerY = (y2 + y) / 2;\n    properties.initProperties = initAnimationProperties(chart, properties, options);\n    if (options.curve) {\n      const p1 = {\n        x: properties.x,\n        y: properties.y\n      };\n      const p2 = {\n        x: properties.x2,\n        y: properties.y2\n      };\n      properties.cp = getControlPoint(properties, options, distanceBetweenPoints(p1, p2));\n    }\n    const labelProperties = resolveLabelElementProperties(chart, properties, options.label);\n    // additonal prop to manage zoom/pan\n    labelProperties._visible = inside;\n    properties.elements = [{\n      type: 'label',\n      optionScope: 'label',\n      properties: labelProperties,\n      initProperties: properties.initProperties\n    }];\n    return properties;\n  }\n}\nLineAnnotation.id = 'lineAnnotation';\nconst arrowHeadsDefaults = {\n  backgroundColor: undefined,\n  backgroundShadowColor: undefined,\n  borderColor: undefined,\n  borderDash: undefined,\n  borderDashOffset: undefined,\n  borderShadowColor: undefined,\n  borderWidth: undefined,\n  display: undefined,\n  fill: undefined,\n  length: undefined,\n  shadowBlur: undefined,\n  shadowOffsetX: undefined,\n  shadowOffsetY: undefined,\n  width: undefined\n};\nLineAnnotation.defaults = {\n  adjustScaleRange: true,\n  arrowHeads: {\n    display: false,\n    end: Object.assign({}, arrowHeadsDefaults),\n    fill: false,\n    length: 12,\n    start: Object.assign({}, arrowHeadsDefaults),\n    width: 6\n  },\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 2,\n  curve: false,\n  controlPoint: {\n    y: '-50%'\n  },\n  display: true,\n  endValue: undefined,\n  init: undefined,\n  hitTolerance: 0,\n  label: {\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    backgroundShadowColor: 'transparent',\n    borderCapStyle: 'butt',\n    borderColor: 'black',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderRadius: 6,\n    borderShadowColor: 'transparent',\n    borderWidth: 0,\n    callout: Object.assign({}, LabelAnnotation.defaults.callout),\n    color: '#fff',\n    content: null,\n    display: false,\n    drawTime: undefined,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    height: undefined,\n    hitTolerance: undefined,\n    opacity: undefined,\n    padding: 6,\n    position: 'center',\n    rotation: 0,\n    shadowBlur: 0,\n    shadowOffsetX: 0,\n    shadowOffsetY: 0,\n    textAlign: 'center',\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    width: undefined,\n    xAdjust: 0,\n    yAdjust: 0,\n    z: undefined\n  },\n  scaleID: undefined,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  value: undefined,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\nLineAnnotation.descriptors = {\n  arrowHeads: {\n    start: {\n      _fallback: true\n    },\n    end: {\n      _fallback: true\n    },\n    _fallback: true\n  }\n};\nLineAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\nfunction inAxisRange(element, _ref18, axis, _ref19) {\n  let {\n    mouseX,\n    mouseY\n  } = _ref18;\n  let {\n    hitSize,\n    useFinalPosition\n  } = _ref19;\n  const limit = rangeLimit(mouseX, mouseY, element.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis);\n  return inLimit(limit, hitSize) || isOnLabel(element, {\n    mouseX,\n    mouseY\n  }, useFinalPosition, axis);\n}\nfunction isLineInArea(_ref20, _ref21) {\n  let {\n    x,\n    y,\n    x2,\n    y2\n  } = _ref20;\n  let {\n    top,\n    right,\n    bottom,\n    left\n  } = _ref21;\n  return !(x < left && x2 < left || x > right && x2 > right || y < top && y2 < top || y > bottom && y2 > bottom);\n}\nfunction limitPointToArea(_ref22, p2, _ref23) {\n  let {\n    x,\n    y\n  } = _ref22;\n  let {\n    top,\n    right,\n    bottom,\n    left\n  } = _ref23;\n  if (x < left) {\n    y = interpolateY(left, {\n      x,\n      y\n    }, p2);\n    x = left;\n  }\n  if (x > right) {\n    y = interpolateY(right, {\n      x,\n      y\n    }, p2);\n    x = right;\n  }\n  if (y < top) {\n    x = interpolateX(top, {\n      x,\n      y\n    }, p2);\n    y = top;\n  }\n  if (y > bottom) {\n    x = interpolateX(bottom, {\n      x,\n      y\n    }, p2);\n    y = bottom;\n  }\n  return {\n    x,\n    y\n  };\n}\nfunction limitLineToArea(p1, p2, area) {\n  const {\n    x,\n    y\n  } = limitPointToArea(p1, p2, area);\n  const {\n    x: x2,\n    y: y2\n  } = limitPointToArea(p2, p1, area);\n  return {\n    x,\n    y,\n    x2,\n    y2,\n    width: Math.abs(x2 - x),\n    height: Math.abs(y2 - y)\n  };\n}\nfunction intersects(element, _ref24) {\n  let {\n    mouseX,\n    mouseY\n  } = _ref24;\n  let epsilon = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSILON;\n  let useFinalPosition = arguments.length > 3 ? arguments[3] : undefined;\n  // Adapted from https://stackoverflow.com/a/6853926/25507\n  const {\n    x: x1,\n    y: y1,\n    x2,\n    y2\n  } = element.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition);\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const lenSq = sqr(dx) + sqr(dy);\n  const t = lenSq === 0 ? -1 : ((mouseX - x1) * dx + (mouseY - y1) * dy) / lenSq;\n  let xx, yy;\n  if (t < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (t > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + t * dx;\n    yy = y1 + t * dy;\n  }\n  return sqr(mouseX - xx) + sqr(mouseY - yy) <= epsilon;\n}\nfunction isOnLabel(element, _ref25, useFinalPosition, axis) {\n  let {\n    mouseX,\n    mouseY\n  } = _ref25;\n  const label = element.label;\n  return label.options.display && label.inRange(mouseX, mouseY, axis, useFinalPosition);\n}\nfunction resolveLabelElementProperties(chart, properties, options) {\n  const borderWidth = options.borderWidth;\n  const padding = toPadding(options.padding);\n  const textSize = measureLabelSize(chart.ctx, options);\n  const width = textSize.width + padding.width + borderWidth;\n  const height = textSize.height + padding.height + borderWidth;\n  return calculateLabelPosition(properties, options, {\n    width,\n    height,\n    padding\n  }, chart.chartArea);\n}\nfunction calculateAutoRotation(properties) {\n  const {\n    x,\n    y,\n    x2,\n    y2\n  } = properties;\n  const rotation = Math.atan2(y2 - y, x2 - x);\n  // Flip the rotation if it goes > PI/2 or < -PI/2, so label stays upright\n  return rotation > PI / 2 ? rotation - PI : rotation < PI / -2 ? rotation + PI : rotation;\n}\nfunction calculateLabelPosition(properties, label, sizes, chartArea) {\n  const {\n    width,\n    height,\n    padding\n  } = sizes;\n  const {\n    xAdjust,\n    yAdjust\n  } = label;\n  const p1 = {\n    x: properties.x,\n    y: properties.y\n  };\n  const p2 = {\n    x: properties.x2,\n    y: properties.y2\n  };\n  const rotation = label.rotation === 'auto' ? calculateAutoRotation(properties) : toRadians(label.rotation);\n  const size = rotatedSize(width, height, rotation);\n  const t = calculateT(properties, label, {\n    labelSize: size,\n    padding\n  }, chartArea);\n  const pt = properties.cp ? pointInCurve(p1, properties.cp, p2, t) : pointInLine(p1, p2, t);\n  const xCoordinateSizes = {\n    size: size.w,\n    min: chartArea.left,\n    max: chartArea.right,\n    padding: padding.left\n  };\n  const yCoordinateSizes = {\n    size: size.h,\n    min: chartArea.top,\n    max: chartArea.bottom,\n    padding: padding.top\n  };\n  const centerX = adjustLabelCoordinate(pt.x, xCoordinateSizes) + xAdjust;\n  const centerY = adjustLabelCoordinate(pt.y, yCoordinateSizes) + yAdjust;\n  return {\n    x: centerX - width / 2,\n    y: centerY - height / 2,\n    x2: centerX + width / 2,\n    y2: centerY + height / 2,\n    centerX,\n    centerY,\n    pointX: pt.x,\n    pointY: pt.y,\n    width,\n    height,\n    rotation: toDegrees(rotation)\n  };\n}\nfunction rotatedSize(width, height, rotation) {\n  const cos = Math.cos(rotation);\n  const sin = Math.sin(rotation);\n  return {\n    w: Math.abs(width * cos) + Math.abs(height * sin),\n    h: Math.abs(width * sin) + Math.abs(height * cos)\n  };\n}\nfunction calculateT(properties, label, sizes, chartArea) {\n  let t;\n  const space = spaceAround(properties, chartArea);\n  if (label.position === 'start') {\n    t = calculateTAdjust({\n      w: properties.x2 - properties.x,\n      h: properties.y2 - properties.y\n    }, sizes, label, space);\n  } else if (label.position === 'end') {\n    t = 1 - calculateTAdjust({\n      w: properties.x - properties.x2,\n      h: properties.y - properties.y2\n    }, sizes, label, space);\n  } else {\n    t = getRelativePosition(1, label.position);\n  }\n  return t;\n}\nfunction calculateTAdjust(lineSize, sizes, label, space) {\n  const {\n    labelSize,\n    padding\n  } = sizes;\n  const lineW = lineSize.w * space.dx;\n  const lineH = lineSize.h * space.dy;\n  const x = lineW > 0 && (labelSize.w / 2 + padding.left - space.x) / lineW;\n  const y = lineH > 0 && (labelSize.h / 2 + padding.top - space.y) / lineH;\n  return clamp(Math.max(x, y), 0, 0.25);\n}\nfunction spaceAround(properties, chartArea) {\n  const {\n    x,\n    x2,\n    y,\n    y2\n  } = properties;\n  const t = Math.min(y, y2) - chartArea.top;\n  const l = Math.min(x, x2) - chartArea.left;\n  const b = chartArea.bottom - Math.max(y, y2);\n  const r = chartArea.right - Math.max(x, x2);\n  return {\n    x: Math.min(l, r),\n    y: Math.min(t, b),\n    dx: l <= r ? 1 : -1,\n    dy: t <= b ? 1 : -1\n  };\n}\nfunction adjustLabelCoordinate(coordinate, labelSizes) {\n  const {\n    size,\n    min,\n    max,\n    padding\n  } = labelSizes;\n  const halfSize = size / 2;\n  if (size > max - min) {\n    // if it does not fit, display as much as possible\n    return (max + min) / 2;\n  }\n  if (min >= coordinate - padding - halfSize) {\n    coordinate = min + padding + halfSize;\n  }\n  if (max <= coordinate + padding + halfSize) {\n    coordinate = max - padding - halfSize;\n  }\n  return coordinate;\n}\nfunction getArrowHeads(line) {\n  const options = line.options;\n  const arrowStartOpts = options.arrowHeads && options.arrowHeads.start;\n  const arrowEndOpts = options.arrowHeads && options.arrowHeads.end;\n  return {\n    startOpts: arrowStartOpts,\n    endOpts: arrowEndOpts,\n    startAdjust: getLineAdjust(line, arrowStartOpts),\n    endAdjust: getLineAdjust(line, arrowEndOpts)\n  };\n}\nfunction getLineAdjust(line, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.display) {\n    return 0;\n  }\n  const {\n    length,\n    width\n  } = arrowOpts;\n  const adjust = line.options.borderWidth / 2;\n  const p1 = {\n    x: length,\n    y: width + adjust\n  };\n  const p2 = {\n    x: 0,\n    y: adjust\n  };\n  return Math.abs(interpolateX(0, p1, p2));\n}\nfunction drawArrowHead(ctx, offset, adjust, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.display) {\n    return;\n  }\n  const {\n    length,\n    width,\n    fill,\n    backgroundColor,\n    borderColor\n  } = arrowOpts;\n  const arrowOffsetX = Math.abs(offset - length) + adjust;\n  ctx.beginPath();\n  setShadowStyle(ctx, arrowOpts);\n  setBorderStyle(ctx, arrowOpts);\n  ctx.moveTo(arrowOffsetX, -width);\n  ctx.lineTo(offset + adjust, 0);\n  ctx.lineTo(arrowOffsetX, width);\n  if (fill === true) {\n    ctx.fillStyle = backgroundColor || borderColor;\n    ctx.closePath();\n    ctx.fill();\n    ctx.shadowColor = 'transparent';\n  } else {\n    ctx.shadowColor = arrowOpts.borderShadowColor;\n  }\n  ctx.stroke();\n}\nfunction getControlPoint(properties, options, distance) {\n  const {\n    x,\n    y,\n    x2,\n    y2,\n    centerX,\n    centerY\n  } = properties;\n  const angle = Math.atan2(y2 - y, x2 - x);\n  const cp = toPosition(options.controlPoint, 0);\n  const point = {\n    x: centerX + getSize(distance, cp.x, false),\n    y: centerY + getSize(distance, cp.y, false)\n  };\n  return rotated(point, {\n    x: centerX,\n    y: centerY\n  }, angle);\n}\nfunction drawArrowHeadOnCurve(ctx, _ref26, _ref27, arrowOpts) {\n  let {\n    x,\n    y\n  } = _ref26;\n  let {\n    angle,\n    adjust\n  } = _ref27;\n  if (!arrowOpts || !arrowOpts.display) {\n    return;\n  }\n  ctx.save();\n  ctx.translate(x, y);\n  ctx.rotate(angle);\n  drawArrowHead(ctx, 0, -adjust, arrowOpts);\n  ctx.restore();\n}\nfunction drawCurve(ctx, element, cp, length) {\n  const {\n    x,\n    y,\n    x2,\n    y2,\n    options\n  } = element;\n  const {\n    startOpts,\n    endOpts,\n    startAdjust,\n    endAdjust\n  } = getArrowHeads(element);\n  const p1 = {\n    x,\n    y\n  };\n  const p2 = {\n    x: x2,\n    y: y2\n  };\n  const startAngle = angleInCurve(p1, cp, p2, 0);\n  const endAngle = angleInCurve(p1, cp, p2, 1) - PI;\n  const ps = pointInCurve(p1, cp, p2, startAdjust / length);\n  const pe = pointInCurve(p1, cp, p2, 1 - endAdjust / length);\n  const path = new Path2D();\n  ctx.beginPath();\n  path.moveTo(ps.x, ps.y);\n  path.quadraticCurveTo(cp.x, cp.y, pe.x, pe.y);\n  ctx.shadowColor = options.borderShadowColor;\n  ctx.stroke(path);\n  element.path = path;\n  element.ctx = ctx;\n  drawArrowHeadOnCurve(ctx, ps, {\n    angle: startAngle,\n    adjust: startAdjust\n  }, startOpts);\n  drawArrowHeadOnCurve(ctx, pe, {\n    angle: endAngle,\n    adjust: endAdjust\n  }, endOpts);\n}\nclass EllipseAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const rotation = this.options.rotation;\n    const hitSize = (this.options.borderWidth + this.options.hitTolerance) / 2;\n    if (axis !== 'x' && axis !== 'y') {\n      return pointInEllipse({\n        x: mouseX,\n        y: mouseY\n      }, this.getProps(['width', 'height', 'centerX', 'centerY'], useFinalPosition), rotation, hitSize);\n    }\n    const {\n      x,\n      y,\n      x2,\n      y2\n    } = this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition);\n    const limit = axis === 'y' ? {\n      start: y,\n      end: y2\n    } : {\n      start: x,\n      end: x2\n    };\n    const rotatedPoint = rotated({\n      x: mouseX,\n      y: mouseY\n    }, this.getCenterPoint(useFinalPosition), toRadians(-rotation));\n    return rotatedPoint[axis] >= limit.start - hitSize - EPSILON && rotatedPoint[axis] <= limit.end + hitSize + EPSILON;\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    const {\n      width,\n      height,\n      centerX,\n      centerY,\n      options\n    } = this;\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), options.rotation);\n    setShadowStyle(ctx, this.options);\n    ctx.beginPath();\n    ctx.fillStyle = options.backgroundColor;\n    const stroke = setBorderStyle(ctx, options);\n    ctx.ellipse(centerX, centerY, height / 2, width / 2, PI / 2, 0, 2 * PI);\n    ctx.fill();\n    if (stroke) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n  get label() {\n    return this.elements && this.elements[0];\n  }\n  resolveElementProperties(chart, options) {\n    return resolveBoxAndLabelProperties(chart, options);\n  }\n}\nEllipseAnnotation.id = 'ellipseAnnotation';\nEllipseAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  hitTolerance: 0,\n  init: undefined,\n  label: Object.assign({}, BoxAnnotation.defaults.label),\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\nEllipseAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nEllipseAnnotation.descriptors = {\n  label: {\n    _fallback: true\n  }\n};\nfunction pointInEllipse(p, ellipse, rotation, hitSize) {\n  const {\n    width,\n    height,\n    centerX,\n    centerY\n  } = ellipse;\n  const xRadius = width / 2;\n  const yRadius = height / 2;\n  if (xRadius <= 0 || yRadius <= 0) {\n    return false;\n  }\n  // https://stackoverflow.com/questions/7946187/point-and-ellipse-rotated-position-test-algorithm\n  const angle = toRadians(rotation || 0);\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n  const a = Math.pow(cosAngle * (p.x - centerX) + sinAngle * (p.y - centerY), 2);\n  const b = Math.pow(sinAngle * (p.x - centerX) - cosAngle * (p.y - centerY), 2);\n  return a / Math.pow(xRadius + hitSize, 2) + b / Math.pow(yRadius + hitSize, 2) <= 1.0001;\n}\nclass PointAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const {\n      x,\n      y,\n      x2,\n      y2,\n      width\n    } = this.getProps(['x', 'y', 'x2', 'y2', 'width'], useFinalPosition);\n    const hitSize = (this.options.borderWidth + this.options.hitTolerance) / 2;\n    if (axis !== 'x' && axis !== 'y') {\n      return inPointRange({\n        x: mouseX,\n        y: mouseY\n      }, this.getCenterPoint(useFinalPosition), width / 2, hitSize);\n    }\n    const limit = axis === 'y' ? {\n      start: y,\n      end: y2,\n      value: mouseY\n    } : {\n      start: x,\n      end: x2,\n      value: mouseX\n    };\n    return inLimit(limit, hitSize);\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    const options = this.options;\n    const borderWidth = options.borderWidth;\n    if (options.radius < 0.1) {\n      return;\n    }\n    ctx.save();\n    ctx.fillStyle = options.backgroundColor;\n    setShadowStyle(ctx, options);\n    const stroke = setBorderStyle(ctx, options);\n    drawPoint(ctx, this, this.centerX, this.centerY);\n    if (stroke && !isImageOrCanvas(options.pointStyle)) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n    options.borderWidth = borderWidth;\n  }\n  resolveElementProperties(chart, options) {\n    const properties = resolvePointProperties(chart, options);\n    properties.initProperties = initAnimationProperties(chart, properties, options);\n    return properties;\n  }\n}\nPointAnnotation.id = 'pointAnnotation';\nPointAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  hitTolerance: 0,\n  init: undefined,\n  pointStyle: 'circle',\n  radius: 10,\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\nPointAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nclass PolygonAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    if (axis !== 'x' && axis !== 'y') {\n      return this.options.radius >= 0.1 && this.elements.length > 1 && pointIsInPolygon(this.elements, mouseX, mouseY, useFinalPosition);\n    }\n    const rotatedPoint = rotated({\n      x: mouseX,\n      y: mouseY\n    }, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));\n    const axisPoints = this.elements.map(point => axis === 'y' ? point.bY : point.bX);\n    const start = Math.min(...axisPoints);\n    const end = Math.max(...axisPoints);\n    return rotatedPoint[axis] >= start && rotatedPoint[axis] <= end;\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    const {\n      elements,\n      options\n    } = this;\n    ctx.save();\n    ctx.beginPath();\n    ctx.fillStyle = options.backgroundColor;\n    setShadowStyle(ctx, options);\n    const stroke = setBorderStyle(ctx, options);\n    let first = true;\n    for (const el of elements) {\n      if (first) {\n        ctx.moveTo(el.x, el.y);\n        first = false;\n      } else {\n        ctx.lineTo(el.x, el.y);\n      }\n    }\n    ctx.closePath();\n    ctx.fill();\n    // If no border, don't draw it\n    if (stroke) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n  resolveElementProperties(chart, options) {\n    const properties = resolvePointProperties(chart, options);\n    const {\n      sides,\n      rotation\n    } = options;\n    const elements = [];\n    const angle = 2 * PI / sides;\n    let rad = rotation * RAD_PER_DEG;\n    for (let i = 0; i < sides; i++, rad += angle) {\n      const elProps = buildPointElement(properties, options, rad);\n      elProps.initProperties = initAnimationProperties(chart, properties, options);\n      elements.push(elProps);\n    }\n    properties.elements = elements;\n    return properties;\n  }\n}\nPolygonAnnotation.id = 'polygonAnnotation';\nPolygonAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  hitTolerance: 0,\n  init: undefined,\n  point: {\n    radius: 0\n  },\n  radius: 10,\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  sides: 3,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\nPolygonAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nfunction buildPointElement(_ref28, _ref29, rad) {\n  let {\n    centerX,\n    centerY\n  } = _ref28;\n  let {\n    radius,\n    borderWidth,\n    hitTolerance\n  } = _ref29;\n  const hitSize = (borderWidth + hitTolerance) / 2;\n  const sin = Math.sin(rad);\n  const cos = Math.cos(rad);\n  const point = {\n    x: centerX + sin * radius,\n    y: centerY - cos * radius\n  };\n  return {\n    type: 'point',\n    optionScope: 'point',\n    properties: {\n      x: point.x,\n      y: point.y,\n      centerX: point.x,\n      centerY: point.y,\n      bX: centerX + sin * (radius + hitSize),\n      bY: centerY - cos * (radius + hitSize)\n    }\n  };\n}\nfunction pointIsInPolygon(points, x, y, useFinalPosition) {\n  let isInside = false;\n  let A = points[points.length - 1].getProps(['bX', 'bY'], useFinalPosition);\n  for (const point of points) {\n    const B = point.getProps(['bX', 'bY'], useFinalPosition);\n    if (B.bY > y !== A.bY > y && x < (A.bX - B.bX) * (y - B.bY) / (A.bY - B.bY) + B.bX) {\n      isInside = !isInside;\n    }\n    A = B;\n  }\n  return isInside;\n}\nconst annotationTypes = {\n  box: BoxAnnotation,\n  doughnutLabel: DoughnutLabelAnnotation,\n  ellipse: EllipseAnnotation,\n  label: LabelAnnotation,\n  line: LineAnnotation,\n  point: PointAnnotation,\n  polygon: PolygonAnnotation\n};\n\n/**\n * Register fallback for annotation elements\n * For example lineAnnotation options would be looked through:\n * - the annotation object (options.plugins.annotation.annotations[id])\n * - element options (options.elements.lineAnnotation)\n * - element defaults (defaults.elements.lineAnnotation)\n * - annotation plugin defaults (defaults.plugins.annotation, this is what we are registering here)\n */\nObject.keys(annotationTypes).forEach(key => {\n  defaults.describe(\"elements.\".concat(annotationTypes[key].id), {\n    _fallback: 'plugins.annotation.common'\n  });\n});\nconst directUpdater = {\n  update: Object.assign\n};\nconst hooks$1 = eventHooks.concat(elementHooks);\nconst resolve = (value, optDefs) => isObject(optDefs) ? resolveObj(value, optDefs) : value;\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import(\"chart.js\").UpdateMode } UpdateMode\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\n */\n\n/**\n * @param {string} prop\n * @returns {boolean}\n */\nconst isIndexable = prop => prop === 'color' || prop === 'font';\n\n/**\n * Resolve the annotation type, checking if is supported.\n * @param {string} [type=line] - annotation type\n * @returns {string} resolved annotation type\n */\nfunction resolveType() {\n  let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'line';\n  if (annotationTypes[type]) {\n    return type;\n  }\n  console.warn(\"Unknown annotation type: '\".concat(type, \"', defaulting to 'line'\"));\n  return 'line';\n}\n\n/**\n * @param {Chart} chart\n * @param {Object} state\n * @param {AnnotationPluginOptions} options\n * @param {UpdateMode} mode\n */\nfunction updateElements(chart, state, options, mode) {\n  const animations = resolveAnimations(chart, options.animations, mode);\n  const annotations = state.annotations;\n  const elements = resyncElements(state.elements, annotations);\n  for (let i = 0; i < annotations.length; i++) {\n    const annotationOptions = annotations[i];\n    const element = getOrCreateElement(elements, i, annotationOptions.type);\n    const resolver = annotationOptions.setContext(getContext(chart, element, elements, annotationOptions));\n    const properties = element.resolveElementProperties(chart, resolver);\n    properties.skip = toSkip(properties);\n    if ('elements' in properties) {\n      updateSubElements(element, properties.elements, resolver, animations);\n      // Remove the sub-element definitions from properties, so the actual elements\n      // are not overwritten by their definitions\n      delete properties.elements;\n    }\n    if (!defined(element.x)) {\n      // If the element is newly created, assing the properties directly - to\n      // make them readily awailable to any scriptable options. If we do not do this,\n      // the properties retruned by `resolveElementProperties` are available only\n      // after options resolution.\n      Object.assign(element, properties);\n    }\n    Object.assign(element, properties.initProperties);\n    properties.options = resolveAnnotationOptions(resolver);\n    animations.update(element, properties);\n  }\n}\nfunction toSkip(properties) {\n  return isNaN(properties.x) || isNaN(properties.y);\n}\nfunction resolveAnimations(chart, animOpts, mode) {\n  if (mode === 'reset' || mode === 'none' || mode === 'resize') {\n    return directUpdater;\n  }\n  return new Animations(chart, animOpts);\n}\nfunction updateSubElements(mainElement, elements, resolver, animations) {\n  const subElements = mainElement.elements || (mainElement.elements = []);\n  subElements.length = elements.length;\n  for (let i = 0; i < elements.length; i++) {\n    const definition = elements[i];\n    const properties = definition.properties;\n    const subElement = getOrCreateElement(subElements, i, definition.type, definition.initProperties);\n    const subResolver = resolver[definition.optionScope].override(definition);\n    properties.options = resolveAnnotationOptions(subResolver);\n    animations.update(subElement, properties);\n  }\n}\nfunction getOrCreateElement(elements, index, type, initProperties) {\n  const elementClass = annotationTypes[resolveType(type)];\n  let element = elements[index];\n  if (!element || !(element instanceof elementClass)) {\n    element = elements[index] = new elementClass();\n    Object.assign(element, initProperties);\n  }\n  return element;\n}\nfunction resolveAnnotationOptions(resolver) {\n  const elementClass = annotationTypes[resolveType(resolver.type)];\n  const result = {};\n  result.id = resolver.id;\n  result.type = resolver.type;\n  result.drawTime = resolver.drawTime;\n  Object.assign(result, resolveObj(resolver, elementClass.defaults), resolveObj(resolver, elementClass.defaultRoutes));\n  for (const hook of hooks$1) {\n    result[hook] = resolver[hook];\n  }\n  return result;\n}\nfunction resolveObj(resolver, defs) {\n  const result = {};\n  for (const prop of Object.keys(defs)) {\n    const optDefs = defs[prop];\n    const value = resolver[prop];\n    if (isIndexable(prop) && isArray(value)) {\n      result[prop] = value.map(item => resolve(item, optDefs));\n    } else {\n      result[prop] = resolve(value, optDefs);\n    }\n  }\n  return result;\n}\nfunction getContext(chart, element, elements, annotation) {\n  return element.$context || (element.$context = Object.assign(Object.create(chart.getContext()), {\n    element,\n    get elements() {\n      return elements.filter(el => el && el.options);\n    },\n    id: annotation.id,\n    type: 'annotation'\n  }));\n}\nfunction resyncElements(elements, annotations) {\n  const count = annotations.length;\n  const start = elements.length;\n  if (start < count) {\n    const add = count - start;\n    elements.splice(start, 0, ...new Array(add));\n  } else if (start > count) {\n    elements.splice(count, start - count);\n  }\n  return elements;\n}\nvar version = \"3.1.0\";\nconst chartStates = new Map();\nconst isNotDoughnutLabel = annotation => annotation.type !== 'doughnutLabel';\nconst hooks = eventHooks.concat(elementHooks);\nvar annotation = {\n  id: 'annotation',\n  version,\n  beforeRegister() {\n    requireVersion('chart.js', '4.0', Chart.version);\n  },\n  afterRegister() {\n    Chart.register(annotationTypes);\n  },\n  afterUnregister() {\n    Chart.unregister(annotationTypes);\n  },\n  beforeInit(chart) {\n    chartStates.set(chart, {\n      annotations: [],\n      elements: [],\n      visibleElements: [],\n      listeners: {},\n      listened: false,\n      moveListened: false,\n      hooks: {},\n      hooked: false,\n      hovered: []\n    });\n  },\n  beforeUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    const annotations = state.annotations = [];\n    let annotationOptions = options.annotations;\n    if (isObject(annotationOptions)) {\n      Object.keys(annotationOptions).forEach(key => {\n        const value = annotationOptions[key];\n        if (isObject(value)) {\n          value.id = key;\n          annotations.push(value);\n        }\n      });\n    } else if (isArray(annotationOptions)) {\n      annotations.push(...annotationOptions);\n    }\n    verifyScaleOptions(annotations.filter(isNotDoughnutLabel), chart.scales);\n  },\n  afterDataLimits(chart, args) {\n    const state = chartStates.get(chart);\n    adjustScaleRange(chart, args.scale, state.annotations.filter(isNotDoughnutLabel).filter(a => a.display && a.adjustScaleRange));\n  },\n  afterUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    updateListeners(chart, state, options);\n    updateElements(chart, state, options, args.mode);\n    state.visibleElements = state.elements.filter(el => !el.skip && el.options.display);\n    updateHooks(chart, state, options);\n  },\n  beforeDatasetsDraw(chart, _args, options) {\n    draw(chart, 'beforeDatasetsDraw', options.clip);\n  },\n  afterDatasetsDraw(chart, _args, options) {\n    draw(chart, 'afterDatasetsDraw', options.clip);\n  },\n  beforeDatasetDraw(chart, _args, options) {\n    draw(chart, _args.index, options.clip);\n  },\n  beforeDraw(chart, _args, options) {\n    draw(chart, 'beforeDraw', options.clip);\n  },\n  afterDraw(chart, _args, options) {\n    draw(chart, 'afterDraw', options.clip);\n  },\n  beforeEvent(chart, args, options) {\n    const state = chartStates.get(chart);\n    if (handleEvent(state, args.event, options)) {\n      args.changed = true;\n    }\n  },\n  afterDestroy(chart) {\n    chartStates.delete(chart);\n  },\n  getAnnotations(chart) {\n    const state = chartStates.get(chart);\n    return state ? state.elements : [];\n  },\n  // only for testing\n  _getAnnotationElementsAtEventForMode(visibleElements, event, options) {\n    return getElements(visibleElements, event, options);\n  },\n  defaults: {\n    animations: {\n      numbers: {\n        properties: ['x', 'y', 'x2', 'y2', 'width', 'height', 'centerX', 'centerY', 'pointX', 'pointY', 'radius'],\n        type: 'number'\n      },\n      colors: {\n        properties: ['backgroundColor', 'borderColor'],\n        type: 'color'\n      }\n    },\n    clip: true,\n    interaction: {\n      mode: undefined,\n      axis: undefined,\n      intersect: undefined\n    },\n    common: {\n      drawTime: 'afterDatasetsDraw',\n      init: false,\n      label: {}\n    }\n  },\n  descriptors: {\n    _indexable: false,\n    _scriptable: prop => !hooks.includes(prop) && prop !== 'init',\n    annotations: {\n      _allKeys: false,\n      _fallback: (prop, opts) => \"elements.\".concat(annotationTypes[resolveType(opts.type)].id)\n    },\n    interaction: {\n      _fallback: true\n    },\n    common: {\n      label: {\n        _indexable: isIndexable,\n        _fallback: true\n      },\n      _indexable: isIndexable\n    }\n  },\n  additionalOptionScopes: ['']\n};\nfunction draw(chart, caller, clip) {\n  const {\n    ctx,\n    chartArea\n  } = chart;\n  const state = chartStates.get(chart);\n  if (clip) {\n    clipArea(ctx, chartArea);\n  }\n  const drawableElements = getDrawableElements(state.visibleElements, caller).sort((a, b) => a.element.options.z - b.element.options.z);\n  for (const item of drawableElements) {\n    drawElement(ctx, chartArea, state, item);\n  }\n  if (clip) {\n    unclipArea(ctx);\n  }\n}\nfunction getDrawableElements(elements, caller) {\n  const drawableElements = [];\n  for (const el of elements) {\n    if (el.options.drawTime === caller) {\n      drawableElements.push({\n        element: el,\n        main: true\n      });\n    }\n    if (el.elements && el.elements.length) {\n      for (const sub of el.elements) {\n        if (sub.options.display && sub.options.drawTime === caller) {\n          drawableElements.push({\n            element: sub\n          });\n        }\n      }\n    }\n  }\n  return drawableElements;\n}\nfunction drawElement(ctx, chartArea, state, item) {\n  const el = item.element;\n  if (item.main) {\n    invokeHook(state, el, 'beforeDraw');\n    el.draw(ctx, chartArea);\n    invokeHook(state, el, 'afterDraw');\n  } else {\n    el.draw(ctx, chartArea);\n  }\n}\nexport { annotation as default };","map":{"version":3,"names":["Element","DoughnutController","defaults","Animations","Chart","distanceBetweenPoints","toRadians","isObject","valueOrDefault","defined","isFunction","callback","isArray","toFont","addRoundedRectPath","toTRBLCorners","QUARTER_PI","PI","HALF_PI","TWO_THIRDS_PI","TAU","isNumber","RAD_PER_DEG","toPadding","isFinite","getAngleFromPoint","toDegrees","clipArea","unclipArea","interaction","modes","point","visibleElements","event","filterElements","intersect","nearest","options","getNearestItem","x","axis","y","getElements","mode","inRangeByAxis","element","inRange","getPointByAxis","center","filter","minDistance","Number","POSITIVE_INFINITY","reduce","nearestItems","getCenterPoint","evenPoint","distance","push","sort","a","b","_index","slice","rotated","angle","cos","Math","sin","cx","cy","isOlderPart","act","req","length","EPSILON","clamp","from","to","min","max","inLimit","limit","hitSize","value","start","end","clampAll","obj","key","Object","keys","inPointRange","radius","pow","inBoxRange","_ref","_ref2","x2","y2","borderWidth","hitTolerance","inRangeX","inRangeY","inLabelRange","_ref3","_ref4","rect","rotation","rotPoint","getElementCenterPoint","useFinalPosition","centerX","centerY","getProps","requireVersion","pkg","ver","strict","arguments","undefined","parts","split","i","parseInt","Error","concat","isPercentString","s","endsWith","toPercent","parseFloat","toPositivePercent","boxAppering","width","height","defaultInitAnimation","box","properties","doughnutLabel","ellipse","label","line","polygon","getRelativePosition","size","position","getSize","positivePercent","calculateTextAlignment","textAlign","measureLabelRectangle","labelSize","_ref5","padding","xAdjust","yAdjust","hasPadding","positionObj","toPosition","calculateLabelPosition$1","defaultValue","shouldFit","fitRatio","autoFit","toFonts","optFont","font","fonts","map","f","floor","lineHeight","isBoundToPoint","xValue","yValue","adjust","initAnimationProperties","chart","initAnim","init","applyDefault","execCallback","loadHooks","hooks","hooksContainer","activated","forEach","hook","type","result","widthCache","Map","notRadius","isNaN","fontsKey","prev","item","string","isImageOrCanvas","content","toString","translate","ctx","_ref6","rotate","setBorderStyle","lineCap","borderCapStyle","setLineDash","borderDash","lineDashOffset","borderDashOffset","lineJoin","borderJoinStyle","lineWidth","strokeStyle","borderColor","setShadowStyle","shadowColor","backgroundShadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","measureLabelSize","strokeWidth","textStrokeWidth","lines","mapKey","join","_measureText","has","set","calculateLabelSize","get","drawBox","save","stroke","fillStyle","backgroundColor","beginPath","w","h","borderRadius","closePath","fill","borderShadowColor","restore","drawLabel","globalAlpha","getOpacity","opacity","style","drawImage","labels","optColor","color","colors","textBaseline","setTextStrokeStyle","applyLabelDecoration","applyLabelContent","miterLimit","textStrokeColor","drawPoint","pointStyle","rad","drawPointStyle","_ref7","xOffset","yOffset","cornerRadius","arc","moveTo","lineTo","SQRT1_2","count","text","measureText","_ref8","lhs","l","lh","strokeText","_ref9","_ref10","c","fillText","elementValue","positions","drawCallout","pointX","pointY","callout","calloutPosition","display","resolveCalloutPosition","isPointInRange","separatorStart","separatorEnd","getCalloutSeparatorCoord","sideStart","sideEnd","getCalloutSideCoord","margin","rotatedPoint","getCalloutSeparatorAdjust","side","getCalloutSideAdjust","includes","resolveCalloutAutoPosition","xPoints","yPoints","index","limitedLineScale","xScaleID","startProp","endProp","yScaleID","scaleValue","scale","fallback","parse","getPixelForValue","retrieveScaleID","scales","scaleID","charAt","axes","values","id","getDimensionByScale","reverse","getChartPoint","chartArea","xScale","yScale","left","top","resolveBoxProperties","right","bottom","xDim","getChartDimensionByScale","xMin","xMax","yDim","yMin","yMax","resolvePointProperties","adjustCenterX","adjustCenterY","getChartCircle","resolveLineProperties","area","resolveFullLineProperties","resolveLimitedLineProperties","resolveBoxAndLabelProperties","initProperties","elements","optionScope","resolveLabelElementProperties$1","NaN","endValue","isHorizontal","scaleId","dim","calculateX","_ref11","calculatePosition","calculateY","_ref12","boxOpts","labelOpts","padStart","padEnd","availableSize","moveHooks","eventHooks","updateListeners","state","listened","listeners","moveListened","annotations","scope","click","handleEvent","handleMoveEvents","handleClickEvents","previous","hovered","context","changed","dispatchMoveEvents","_ref13","checkElements","indexOf","dispatchEvent","handler","$context","elementHooks","updateHooks","hooked","invokeHook","callbackHook","adjustScaleRange","range","getScaleLimits","changeScaleLimit","handleTickRangeOptions","verifyScaleOptions","annotation","verifyScaleIDs","suggestedLimit","scaleLimitDefined","scaleOptions","verifyProperties","console","warn","prop","scaleIDOption","limits","NEGATIVE_INFINITY","updateLimits","props","raw","BoxAnnotation","mouseX","mouseY","draw","resolveElementProperties","drawTime","family","weight","z","defaultRoutes","descriptors","_fallback","DoughnutLabelAnnotation","drawBackground","_fitRatio","meta","getDatasetMeta","controllerMeta","getControllerMeta","getFitRatio","boxSize","_objectSpread","autoHide","spacing","getSortedVisibleDatasetMetas","controller","isControllerVisible","data","innerRadius","circumference","hidden","getDataVisibility","_ref14","offsetX","offsetY","square","space","_radius","_counterclockwise","angles","getAngles","_centerX","_centerY","_ref15","hypo","sqrt","yk2","r2","delta","_startAngle","_endAngle","LabelAnnotation","visible","_visible","getLabelSize","_ref16","hBorderWidth","pointInLine","p1","p2","t","interpolateX","abs","interpolateY","sqr","v","rangeLimit","_ref17","coordInCurve","cp","pointInCurve","coordAngleInCurve","angleInCurve","atan2","LineAnnotation","path","mx","currentDevicePixelRatio","my","isPointInStroke","isOnLabel","epsilon","intersects","inAxisRange","curve","drawCurve","startOpts","endOpts","startAdjust","endAdjust","getArrowHeads","drawArrowHead","inside","isLineInArea","limitLineToArea","getControlPoint","labelProperties","resolveLabelElementProperties","arrowHeadsDefaults","arrowHeads","assign","controlPoint","_ref18","_ref19","_ref20","_ref21","limitPointToArea","_ref22","_ref23","_ref24","x1","y1","dx","dy","lenSq","xx","yy","_ref25","textSize","calculateLabelPosition","calculateAutoRotation","sizes","rotatedSize","calculateT","pt","xCoordinateSizes","yCoordinateSizes","adjustLabelCoordinate","spaceAround","calculateTAdjust","lineSize","lineW","lineH","r","coordinate","labelSizes","halfSize","arrowStartOpts","arrowEndOpts","getLineAdjust","arrowOpts","offset","arrowOffsetX","drawArrowHeadOnCurve","_ref26","_ref27","startAngle","endAngle","ps","pe","Path2D","quadraticCurveTo","EllipseAnnotation","pointInEllipse","p","xRadius","yRadius","cosAngle","sinAngle","PointAnnotation","PolygonAnnotation","pointIsInPolygon","axisPoints","bY","bX","first","el","sides","elProps","buildPointElement","_ref28","_ref29","points","isInside","A","B","annotationTypes","describe","directUpdater","update","hooks$1","resolve","optDefs","resolveObj","isIndexable","resolveType","updateElements","animations","resolveAnimations","resyncElements","annotationOptions","getOrCreateElement","resolver","setContext","getContext","skip","toSkip","updateSubElements","resolveAnnotationOptions","animOpts","mainElement","subElements","definition","subElement","subResolver","override","elementClass","defs","create","add","splice","Array","version","chartStates","isNotDoughnutLabel","beforeRegister","afterRegister","register","afterUnregister","unregister","beforeInit","beforeUpdate","args","afterDataLimits","afterUpdate","beforeDatasetsDraw","_args","clip","afterDatasetsDraw","beforeDatasetDraw","beforeDraw","afterDraw","beforeEvent","afterDestroy","delete","getAnnotations","_getAnnotationElementsAtEventForMode","numbers","common","_indexable","_scriptable","_allKeys","opts","additionalOptionScopes","caller","drawableElements","getDrawableElements","drawElement","main","sub","default"],"sources":["/Users/dtak/Research/ToO/frontend/node_modules/chartjs-plugin-annotation/dist/chartjs-plugin-annotation.esm.js"],"sourcesContent":["/*!\n* chartjs-plugin-annotation v3.1.0\n* https://www.chartjs.org/chartjs-plugin-annotation/index\n * (c) 2024 chartjs-plugin-annotation Contributors\n * Released under the MIT License\n */\nimport { Element, DoughnutController, defaults, Animations, Chart } from 'chart.js';\nimport { distanceBetweenPoints, toRadians, isObject, valueOrDefault, defined, isFunction, callback, isArray, toFont, addRoundedRectPath, toTRBLCorners, QUARTER_PI, PI, HALF_PI, TWO_THIRDS_PI, TAU, isNumber, RAD_PER_DEG, toPadding, isFinite, getAngleFromPoint, toDegrees, clipArea, unclipArea } from 'chart.js/helpers';\n\n/**\n * @typedef { import(\"chart.js\").ChartEvent } ChartEvent\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */\n\nconst interaction = {\n  modes: {\n    /**\n     * Point mode returns all elements that hit test based on the event position\n     * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n     * @param {ChartEvent} event - the event we are find things at\n     * @return {AnnotationElement[]} - elements that are found\n     */\n    point(visibleElements, event) {\n      return filterElements(visibleElements, event, {intersect: true});\n    },\n\n    /**\n     * Nearest mode returns the element closest to the event position\n     * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n     * @param {ChartEvent} event - the event we are find things at\n     * @param {Object} options - interaction options to use\n     * @return {AnnotationElement[]} - elements that are found (only 1 element)\n     */\n    nearest(visibleElements, event, options) {\n      return getNearestItem(visibleElements, event, options);\n    },\n    /**\n     * x mode returns the elements that hit-test at the current x coordinate\n     * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n     * @param {ChartEvent} event - the event we are find things at\n     * @param {Object} options - interaction options to use\n     * @return {AnnotationElement[]} - elements that are found\n     */\n    x(visibleElements, event, options) {\n      return filterElements(visibleElements, event, {intersect: options.intersect, axis: 'x'});\n    },\n\n    /**\n     * y mode returns the elements that hit-test at the current y coordinate\n     * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n     * @param {ChartEvent} event - the event we are find things at\n     * @param {Object} options - interaction options to use\n     * @return {AnnotationElement[]} - elements that are found\n     */\n    y(visibleElements, event, options) {\n      return filterElements(visibleElements, event, {intersect: options.intersect, axis: 'y'});\n    }\n  }\n};\n\n/**\n * Returns all elements that hit test based on the event position\n * @param {AnnotationElement[]} visibleElements - annotation elements which are visible\n * @param {ChartEvent} event - the event we are find things at\n * @param {Object} options - interaction options to use\n * @return {AnnotationElement[]} - elements that are found\n */\nfunction getElements(visibleElements, event, options) {\n  const mode = interaction.modes[options.mode] || interaction.modes.nearest;\n  return mode(visibleElements, event, options);\n}\n\nfunction inRangeByAxis(element, event, axis) {\n  if (axis !== 'x' && axis !== 'y') {\n    return element.inRange(event.x, event.y, 'x', true) || element.inRange(event.x, event.y, 'y', true);\n  }\n  return element.inRange(event.x, event.y, axis, true);\n}\n\nfunction getPointByAxis(event, center, axis) {\n  if (axis === 'x') {\n    return {x: event.x, y: center.y};\n  } else if (axis === 'y') {\n    return {x: center.x, y: event.y};\n  }\n  return center;\n}\n\nfunction filterElements(visibleElements, event, options) {\n  return visibleElements.filter((element) => options.intersect ? element.inRange(event.x, event.y) : inRangeByAxis(element, event, options.axis));\n}\n\nfunction getNearestItem(visibleElements, event, options) {\n  let minDistance = Number.POSITIVE_INFINITY;\n\n  return filterElements(visibleElements, event, options)\n    .reduce((nearestItems, element) => {\n      const center = element.getCenterPoint();\n      const evenPoint = getPointByAxis(event, center, options.axis);\n      const distance = distanceBetweenPoints(event, evenPoint);\n      if (distance < minDistance) {\n        nearestItems = [element];\n        minDistance = distance;\n      } else if (distance === minDistance) {\n        // Can have multiple items at the same distance in which case we sort by size\n        nearestItems.push(element);\n      }\n\n      return nearestItems;\n    }, [])\n    .sort((a, b) => a._index - b._index)\n    .slice(0, 1); // return only the top item;\n}\n\n/**\n * @typedef {import('chart.js').Point} Point\n */\n\n/**\n * Rotate a `point` relative to `center` point by `angle`\n * @param {Point} point - the point to rotate\n * @param {Point} center - center point for rotation\n * @param {number} angle - angle for rotation, in radians\n * @returns {Point} rotated point\n */\nfunction rotated(point, center, angle) {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  const cx = center.x;\n  const cy = center.y;\n\n  return {\n    x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n    y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n  };\n}\n\nconst isOlderPart = (act, req) => req > act || (act.length > req.length && act.slice(0, req.length) === req);\n\n/**\n * @typedef { import('chart.js').Point } Point\n * @typedef { import('chart.js').InteractionAxis } InteractionAxis\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */\n\nconst EPSILON = 0.001;\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\n\n/**\n * @param {{value: number, start: number, end: number}} limit\n * @param {number} hitSize\n * @returns {boolean}\n */\nconst inLimit = (limit, hitSize) => limit.value >= limit.start - hitSize && limit.value <= limit.end + hitSize;\n\n/**\n * @param {Object} obj\n * @param {number} from\n * @param {number} to\n * @returns {Object}\n */\nfunction clampAll(obj, from, to) {\n  for (const key of Object.keys(obj)) {\n    obj[key] = clamp(obj[key], from, to);\n  }\n  return obj;\n}\n\n/**\n * @param {Point} point\n * @param {Point} center\n * @param {number} radius\n * @param {number} hitSize\n * @returns {boolean}\n */\nfunction inPointRange(point, center, radius, hitSize) {\n  if (!point || !center || radius <= 0) {\n    return false;\n  }\n  return (Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2)) <= Math.pow(radius + hitSize, 2);\n}\n\n/**\n * @param {Point} point\n * @param {{x: number, y: number, x2: number, y2: number}} rect\n * @param {InteractionAxis} axis\n * @param {{borderWidth: number, hitTolerance: number}} hitsize\n * @returns {boolean}\n */\nfunction inBoxRange(point, {x, y, x2, y2}, axis, {borderWidth, hitTolerance}) {\n  const hitSize = (borderWidth + hitTolerance) / 2;\n  const inRangeX = point.x >= x - hitSize - EPSILON && point.x <= x2 + hitSize + EPSILON;\n  const inRangeY = point.y >= y - hitSize - EPSILON && point.y <= y2 + hitSize + EPSILON;\n  if (axis === 'x') {\n    return inRangeX;\n  } else if (axis === 'y') {\n    return inRangeY;\n  }\n  return inRangeX && inRangeY;\n}\n\n/**\n * @param {Point} point\n * @param {rect: {x: number, y: number, x2: number, y2: number}, center: {x: number, y: number}} element\n * @param {InteractionAxis} axis\n * @param {{rotation: number, borderWidth: number, hitTolerance: number}}\n * @returns {boolean}\n */\nfunction inLabelRange(point, {rect, center}, axis, {rotation, borderWidth, hitTolerance}) {\n  const rotPoint = rotated(point, center, toRadians(-rotation));\n  return inBoxRange(rotPoint, rect, axis, {borderWidth, hitTolerance});\n}\n\n/**\n * @param {AnnotationElement} element\n * @param {boolean} useFinalPosition\n * @returns {Point}\n */\nfunction getElementCenterPoint(element, useFinalPosition) {\n  const {centerX, centerY} = element.getProps(['centerX', 'centerY'], useFinalPosition);\n  return {x: centerX, y: centerY};\n}\n\n/**\n * @param {string} pkg\n * @param {string} min\n * @param {string} ver\n * @param {boolean} [strict=true]\n * @returns {boolean}\n */\nfunction requireVersion(pkg, min, ver, strict = true) {\n  const parts = ver.split('.');\n  let i = 0;\n  for (const req of min.split('.')) {\n    const act = parts[i++];\n    if (parseInt(req, 10) < parseInt(act, 10)) {\n      break;\n    }\n    if (isOlderPart(act, req)) {\n      if (strict) {\n        throw new Error(`${pkg} v${ver} is not supported. v${min} or newer is required.`);\n      } else {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nconst isPercentString = (s) => typeof s === 'string' && s.endsWith('%');\nconst toPercent = (s) => parseFloat(s) / 100;\nconst toPositivePercent = (s) => clamp(toPercent(s), 0, 1);\n\nconst boxAppering = (x, y) => ({x, y, x2: x, y2: y, width: 0, height: 0});\nconst defaultInitAnimation = {\n  box: (properties) => boxAppering(properties.centerX, properties.centerY),\n  doughnutLabel: (properties) => boxAppering(properties.centerX, properties.centerY),\n  ellipse: (properties) => ({centerX: properties.centerX, centerY: properties.centerX, radius: 0, width: 0, height: 0}),\n  label: (properties) => boxAppering(properties.centerX, properties.centerY),\n  line: (properties) => boxAppering(properties.x, properties.y),\n  point: (properties) => ({centerX: properties.centerX, centerY: properties.centerY, radius: 0, width: 0, height: 0}),\n  polygon: (properties) => boxAppering(properties.centerX, properties.centerY)\n};\n\n/**\n * @typedef { import('chart.js').FontSpec } FontSpec\n * @typedef { import('chart.js').Point } Point\n * @typedef { import('chart.js').Padding } Padding\n * @typedef { import('../../types/element').AnnotationBoxModel } AnnotationBoxModel\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n * @typedef { import('../../types/options').AnnotationPointCoordinates } AnnotationPointCoordinates\n * @typedef { import('../../types/label').CoreLabelOptions } CoreLabelOptions\n * @typedef { import('../../types/label').LabelPositionObject } LabelPositionObject\n */\n\n/**\n * @param {number} size\n * @param {number|string} position\n * @returns {number}\n */\nfunction getRelativePosition(size, position) {\n  if (position === 'start') {\n    return 0;\n  }\n  if (position === 'end') {\n    return size;\n  }\n  if (isPercentString(position)) {\n    return toPositivePercent(position) * size;\n  }\n  return size / 2;\n}\n\n/**\n * @param {number} size\n * @param {number|string} value\n * @param {boolean} [positivePercent=true]\n * @returns {number}\n */\nfunction getSize(size, value, positivePercent = true) {\n  if (typeof value === 'number') {\n    return value;\n  } else if (isPercentString(value)) {\n    return (positivePercent ? toPositivePercent(value) : toPercent(value)) * size;\n  }\n  return size;\n}\n\n/**\n * @param {{x: number, width: number}} size\n * @param {CoreLabelOptions} options\n * @returns {number}\n */\nfunction calculateTextAlignment(size, options) {\n  const {x, width} = size;\n  const textAlign = options.textAlign;\n  if (textAlign === 'center') {\n    return x + width / 2;\n  } else if (textAlign === 'end' || textAlign === 'right') {\n    return x + width;\n  }\n  return x;\n}\n\n/**\n * @param {Point} point\n * @param {{height: number, width: number}} labelSize\n * @param {{borderWidth: number, position: {LabelPositionObject|string}, xAdjust: number, yAdjust: number}} options\n * @param {Padding|undefined} padding\n * @returns {{x: number, y: number, x2: number, y2: number, height: number, width: number, centerX: number, centerY: number}}\n */\nfunction measureLabelRectangle(point, labelSize, {borderWidth, position, xAdjust, yAdjust}, padding) {\n  const hasPadding = isObject(padding);\n  const width = labelSize.width + (hasPadding ? padding.width : 0) + borderWidth;\n  const height = labelSize.height + (hasPadding ? padding.height : 0) + borderWidth;\n  const positionObj = toPosition(position);\n  const x = calculateLabelPosition$1(point.x, width, xAdjust, positionObj.x);\n  const y = calculateLabelPosition$1(point.y, height, yAdjust, positionObj.y);\n\n  return {\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n    width,\n    height,\n    centerX: x + width / 2,\n    centerY: y + height / 2\n  };\n}\n\n/**\n * @param {LabelPositionObject|string} value\n * @param {string|number} defaultValue\n * @returns {LabelPositionObject}\n */\nfunction toPosition(value, defaultValue = 'center') {\n  if (isObject(value)) {\n    return {\n      x: valueOrDefault(value.x, defaultValue),\n      y: valueOrDefault(value.y, defaultValue),\n    };\n  }\n  value = valueOrDefault(value, defaultValue);\n  return {\n    x: value,\n    y: value\n  };\n}\n\n/**\n * @param {CoreLabelOptions} options\n * @param {number} fitRatio\n * @returns {boolean}\n */\nconst shouldFit = (options, fitRatio) => options && options.autoFit && fitRatio < 1;\n\n/**\n * @param {CoreLabelOptions} options\n * @param {number} fitRatio\n * @returns {FontSpec[]}\n */\nfunction toFonts(options, fitRatio) {\n  const optFont = options.font;\n  const fonts = isArray(optFont) ? optFont : [optFont];\n  if (shouldFit(options, fitRatio)) {\n    return fonts.map(function(f) {\n      const font = toFont(f);\n      font.size = Math.floor(f.size * fitRatio);\n      font.lineHeight = f.lineHeight;\n      return toFont(font);\n    });\n  }\n  return fonts.map(f => toFont(f));\n}\n\n/**\n * @param {AnnotationPointCoordinates} options\n * @returns {boolean}\n */\nfunction isBoundToPoint(options) {\n  return options && (defined(options.xValue) || defined(options.yValue));\n}\n\nfunction calculateLabelPosition$1(start, size, adjust = 0, position) {\n  return start - getRelativePosition(size, position) + adjust;\n}\n\n/**\n * @param {Chart} chart\n * @param {AnnotationBoxModel} properties\n * @param {CoreAnnotationOptions} options\n * @returns {AnnotationElement}\n */\nfunction initAnimationProperties(chart, properties, options) {\n  const initAnim = options.init;\n  if (!initAnim) {\n    return;\n  } else if (initAnim === true) {\n    return applyDefault(properties, options);\n  }\n  return execCallback(chart, properties, options);\n}\n\n/**\n * @param {Object} options\n * @param {Array} hooks\n * @param {Object} hooksContainer\n * @returns {boolean}\n */\nfunction loadHooks(options, hooks, hooksContainer) {\n  let activated = false;\n  hooks.forEach(hook => {\n    if (isFunction(options[hook])) {\n      activated = true;\n      hooksContainer[hook] = options[hook];\n    } else if (defined(hooksContainer[hook])) {\n      delete hooksContainer[hook];\n    }\n  });\n  return activated;\n}\n\nfunction applyDefault(properties, options) {\n  const type = options.type || 'line';\n  return defaultInitAnimation[type](properties);\n}\n\nfunction execCallback(chart, properties, options) {\n  const result = callback(options.init, [{chart, properties, options}]);\n  if (result === true) {\n    return applyDefault(properties, options);\n  } else if (isObject(result)) {\n    return result;\n  }\n}\n\nconst widthCache = new Map();\nconst notRadius = (radius) => isNaN(radius) || radius <= 0;\nconst fontsKey = (fonts) => fonts.reduce(function(prev, item) {\n  prev += item.string;\n  return prev;\n}, '');\n\n/**\n * @typedef { import('chart.js').Point } Point\n * @typedef { import('../../types/label').CoreLabelOptions } CoreLabelOptions\n * @typedef { import('../../types/options').PointAnnotationOptions } PointAnnotationOptions\n */\n\n/**\n * Determine if content is an image or a canvas.\n * @param {*} content\n * @returns boolean|undefined\n * @todo move this function to chart.js helpers\n */\nfunction isImageOrCanvas(content) {\n  if (content && typeof content === 'object') {\n    const type = content.toString();\n    return (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]');\n  }\n}\n\n/**\n * Set the translation on the canvas if the rotation must be applied.\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {Point} point - the point of translation\n * @param {number} rotation - rotation (in degrees) to apply\n */\nfunction translate(ctx, {x, y}, rotation) {\n  if (rotation) {\n    ctx.translate(x, y);\n    ctx.rotate(toRadians(rotation));\n    ctx.translate(-x, -y);\n  }\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {Object} options\n * @returns {boolean|undefined}\n */\nfunction setBorderStyle(ctx, options) {\n  if (options && options.borderWidth) {\n    ctx.lineCap = options.borderCapStyle || 'butt';\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.lineJoin = options.borderJoinStyle || 'miter';\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    return true;\n  }\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {Object} options\n */\nfunction setShadowStyle(ctx, options) {\n  ctx.shadowColor = options.backgroundShadowColor;\n  ctx.shadowBlur = options.shadowBlur;\n  ctx.shadowOffsetX = options.shadowOffsetX;\n  ctx.shadowOffsetY = options.shadowOffsetY;\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {CoreLabelOptions} options\n * @returns {{width: number, height: number}}\n */\nfunction measureLabelSize(ctx, options) {\n  const content = options.content;\n  if (isImageOrCanvas(content)) {\n    const size = {\n      width: getSize(content.width, options.width),\n      height: getSize(content.height, options.height)\n    };\n    return size;\n  }\n  const fonts = toFonts(options);\n  const strokeWidth = options.textStrokeWidth;\n  const lines = isArray(content) ? content : [content];\n  const mapKey = lines.join() + fontsKey(fonts) + strokeWidth + (ctx._measureText ? '-spriting' : '');\n  if (!widthCache.has(mapKey)) {\n    widthCache.set(mapKey, calculateLabelSize(ctx, lines, fonts, strokeWidth));\n  }\n  return widthCache.get(mapKey);\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {{x: number, y: number, width: number, height: number}} rect\n * @param {Object} options\n */\nfunction drawBox(ctx, rect, options) {\n  const {x, y, width, height} = rect;\n  ctx.save();\n  setShadowStyle(ctx, options);\n  const stroke = setBorderStyle(ctx, options);\n  ctx.fillStyle = options.backgroundColor;\n  ctx.beginPath();\n  addRoundedRectPath(ctx, {\n    x, y, w: width, h: height,\n    radius: clampAll(toTRBLCorners(options.borderRadius), 0, Math.min(width, height) / 2)\n  });\n  ctx.closePath();\n  ctx.fill();\n  if (stroke) {\n    ctx.shadowColor = options.borderShadowColor;\n    ctx.stroke();\n  }\n  ctx.restore();\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {{x: number, y: number, width: number, height: number}} rect\n * @param {CoreLabelOptions} options\n * @param {number} fitRatio\n */\nfunction drawLabel(ctx, rect, options, fitRatio) {\n  const content = options.content;\n  if (isImageOrCanvas(content)) {\n    ctx.save();\n    ctx.globalAlpha = getOpacity(options.opacity, content.style.opacity);\n    ctx.drawImage(content, rect.x, rect.y, rect.width, rect.height);\n    ctx.restore();\n    return;\n  }\n  const labels = isArray(content) ? content : [content];\n  const fonts = toFonts(options, fitRatio);\n  const optColor = options.color;\n  const colors = isArray(optColor) ? optColor : [optColor];\n  const x = calculateTextAlignment(rect, options);\n  const y = rect.y + options.textStrokeWidth / 2;\n  ctx.save();\n  ctx.textBaseline = 'middle';\n  ctx.textAlign = options.textAlign;\n  if (setTextStrokeStyle(ctx, options)) {\n    applyLabelDecoration(ctx, {x, y}, labels, fonts);\n  }\n  applyLabelContent(ctx, {x, y}, labels, {fonts, colors});\n  ctx.restore();\n}\n\nfunction setTextStrokeStyle(ctx, options) {\n  if (options.textStrokeWidth > 0) {\n    // https://stackoverflow.com/questions/13627111/drawing-text-with-an-outer-stroke-with-html5s-canvas\n    ctx.lineJoin = 'round';\n    ctx.miterLimit = 2;\n    ctx.lineWidth = options.textStrokeWidth;\n    ctx.strokeStyle = options.textStrokeColor;\n    return true;\n  }\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {{radius: number, options: PointAnnotationOptions}} element\n * @param {number} x\n * @param {number} y\n */\nfunction drawPoint(ctx, element, x, y) {\n  const {radius, options} = element;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n\n  if (isImageOrCanvas(style)) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(rad);\n    ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n    ctx.restore();\n    return;\n  }\n  if (notRadius(radius)) {\n    return;\n  }\n  drawPointStyle(ctx, {x, y, radius, rotation, style, rad});\n}\n\nfunction drawPointStyle(ctx, {x, y, radius, rotation, style, rad}) {\n  let xOffset, yOffset, size, cornerRadius;\n  ctx.beginPath();\n\n  switch (style) {\n  // Default includes circle\n  default:\n    ctx.arc(x, y, radius, 0, TAU);\n    ctx.closePath();\n    break;\n  case 'triangle':\n    ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    rad += TWO_THIRDS_PI;\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    rad += TWO_THIRDS_PI;\n    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n    ctx.closePath();\n    break;\n  case 'rectRounded':\n    // NOTE: the rounded rect implementation changed to use `arc` instead of\n    // `quadraticCurveTo` since it generates better results when rect is\n    // almost a circle. 0.516 (instead of 0.5) produces results with visually\n    // closer proportion to the previous impl and it is inscribed in the\n    // circle with `radius`. For more details, see the following PRs:\n    // https://github.com/chartjs/Chart.js/issues/5597\n    // https://github.com/chartjs/Chart.js/issues/5858\n    cornerRadius = radius * 0.516;\n    size = radius - cornerRadius;\n    xOffset = Math.cos(rad + QUARTER_PI) * size;\n    yOffset = Math.sin(rad + QUARTER_PI) * size;\n    ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n    ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n    ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n    ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n    ctx.closePath();\n    break;\n  case 'rect':\n    if (!rotation) {\n      size = Math.SQRT1_2 * radius;\n      ctx.rect(x - size, y - size, 2 * size, 2 * size);\n      break;\n    }\n    rad += QUARTER_PI;\n    /* falls through */\n  case 'rectRot':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    ctx.closePath();\n    break;\n  case 'crossRot':\n    rad += QUARTER_PI;\n    /* falls through */\n  case 'cross':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    break;\n  case 'star':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    rad += QUARTER_PI;\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    ctx.moveTo(x + yOffset, y - xOffset);\n    ctx.lineTo(x - yOffset, y + xOffset);\n    break;\n  case 'line':\n    xOffset = Math.cos(rad) * radius;\n    yOffset = Math.sin(rad) * radius;\n    ctx.moveTo(x - xOffset, y - yOffset);\n    ctx.lineTo(x + xOffset, y + yOffset);\n    break;\n  case 'dash':\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n    break;\n  }\n\n  ctx.fill();\n}\n\nfunction calculateLabelSize(ctx, lines, fonts, strokeWidth) {\n  ctx.save();\n  const count = lines.length;\n  let width = 0;\n  let height = strokeWidth;\n  for (let i = 0; i < count; i++) {\n    const font = fonts[Math.min(i, fonts.length - 1)];\n    ctx.font = font.string;\n    const text = lines[i];\n    width = Math.max(width, ctx.measureText(text).width + strokeWidth);\n    height += font.lineHeight;\n  }\n  ctx.restore();\n  return {width, height};\n}\n\nfunction applyLabelDecoration(ctx, {x, y}, labels, fonts) {\n  ctx.beginPath();\n  let lhs = 0;\n  labels.forEach(function(l, i) {\n    const f = fonts[Math.min(i, fonts.length - 1)];\n    const lh = f.lineHeight;\n    ctx.font = f.string;\n    ctx.strokeText(l, x, y + lh / 2 + lhs);\n    lhs += lh;\n  });\n  ctx.stroke();\n}\n\nfunction applyLabelContent(ctx, {x, y}, labels, {fonts, colors}) {\n  let lhs = 0;\n  labels.forEach(function(l, i) {\n    const c = colors[Math.min(i, colors.length - 1)];\n    const f = fonts[Math.min(i, fonts.length - 1)];\n    const lh = f.lineHeight;\n    ctx.beginPath();\n    ctx.font = f.string;\n    ctx.fillStyle = c;\n    ctx.fillText(l, x, y + lh / 2 + lhs);\n    lhs += lh;\n    ctx.fill();\n  });\n}\n\nfunction getOpacity(value, elementValue) {\n  const opacity = isNumber(value) ? value : elementValue;\n  return isNumber(opacity) ? clamp(opacity, 0, 1) : 1;\n}\n\nconst positions = ['left', 'bottom', 'top', 'right'];\n\n/**\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */\n\n/**\n * Drawa the callout component for labels.\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {AnnotationElement} element - the label element\n */\nfunction drawCallout(ctx, element) {\n  const {pointX, pointY, options} = element;\n  const callout = options.callout;\n  const calloutPosition = callout && callout.display && resolveCalloutPosition(element, callout);\n  if (!calloutPosition || isPointInRange(element, callout, calloutPosition)) {\n    return;\n  }\n\n  ctx.save();\n  ctx.beginPath();\n  const stroke = setBorderStyle(ctx, callout);\n  if (!stroke) {\n    return ctx.restore();\n  }\n  const {separatorStart, separatorEnd} = getCalloutSeparatorCoord(element, calloutPosition);\n  const {sideStart, sideEnd} = getCalloutSideCoord(element, calloutPosition, separatorStart);\n  if (callout.margin > 0 || options.borderWidth === 0) {\n    ctx.moveTo(separatorStart.x, separatorStart.y);\n    ctx.lineTo(separatorEnd.x, separatorEnd.y);\n  }\n  ctx.moveTo(sideStart.x, sideStart.y);\n  ctx.lineTo(sideEnd.x, sideEnd.y);\n  const rotatedPoint = rotated({x: pointX, y: pointY}, element.getCenterPoint(), toRadians(-element.rotation));\n  ctx.lineTo(rotatedPoint.x, rotatedPoint.y);\n  ctx.stroke();\n  ctx.restore();\n}\n\nfunction getCalloutSeparatorCoord(element, position) {\n  const {x, y, x2, y2} = element;\n  const adjust = getCalloutSeparatorAdjust(element, position);\n  let separatorStart, separatorEnd;\n  if (position === 'left' || position === 'right') {\n    separatorStart = {x: x + adjust, y};\n    separatorEnd = {x: separatorStart.x, y: y2};\n  } else {\n    //  position 'top' or 'bottom'\n    separatorStart = {x, y: y + adjust};\n    separatorEnd = {x: x2, y: separatorStart.y};\n  }\n  return {separatorStart, separatorEnd};\n}\n\nfunction getCalloutSeparatorAdjust(element, position) {\n  const {width, height, options} = element;\n  const adjust = options.callout.margin + options.borderWidth / 2;\n  if (position === 'right') {\n    return width + adjust;\n  } else if (position === 'bottom') {\n    return height + adjust;\n  }\n  return -adjust;\n}\n\nfunction getCalloutSideCoord(element, position, separatorStart) {\n  const {y, width, height, options} = element;\n  const start = options.callout.start;\n  const side = getCalloutSideAdjust(position, options.callout);\n  let sideStart, sideEnd;\n  if (position === 'left' || position === 'right') {\n    sideStart = {x: separatorStart.x, y: y + getSize(height, start)};\n    sideEnd = {x: sideStart.x + side, y: sideStart.y};\n  } else {\n    //  position 'top' or 'bottom'\n    sideStart = {x: separatorStart.x + getSize(width, start), y: separatorStart.y};\n    sideEnd = {x: sideStart.x, y: sideStart.y + side};\n  }\n  return {sideStart, sideEnd};\n}\n\nfunction getCalloutSideAdjust(position, options) {\n  const side = options.side;\n  if (position === 'left' || position === 'top') {\n    return -side;\n  }\n  return side;\n}\n\nfunction resolveCalloutPosition(element, options) {\n  const position = options.position;\n  if (positions.includes(position)) {\n    return position;\n  }\n  return resolveCalloutAutoPosition(element, options);\n}\n\nfunction resolveCalloutAutoPosition(element, options) {\n  const {x, y, x2, y2, width, height, pointX, pointY, centerX, centerY, rotation} = element;\n  const center = {x: centerX, y: centerY};\n  const start = options.start;\n  const xAdjust = getSize(width, start);\n  const yAdjust = getSize(height, start);\n  const xPoints = [x, x + xAdjust, x + xAdjust, x2];\n  const yPoints = [y + yAdjust, y2, y, y2];\n  const result = [];\n  for (let index = 0; index < 4; index++) {\n    const rotatedPoint = rotated({x: xPoints[index], y: yPoints[index]}, center, toRadians(rotation));\n    result.push({\n      position: positions[index],\n      distance: distanceBetweenPoints(rotatedPoint, {x: pointX, y: pointY})\n    });\n  }\n  return result.sort((a, b) => a.distance - b.distance)[0].position;\n}\n\nfunction isPointInRange(element, callout, position) {\n  const {pointX, pointY} = element;\n  const margin = callout.margin;\n  let x = pointX;\n  let y = pointY;\n  if (position === 'left') {\n    x += margin;\n  } else if (position === 'right') {\n    x -= margin;\n  } else if (position === 'top') {\n    y += margin;\n  } else if (position === 'bottom') {\n    y -= margin;\n  }\n  return element.inRange(x, y);\n}\n\nconst limitedLineScale = {\n  xScaleID: {min: 'xMin', max: 'xMax', start: 'left', end: 'right', startProp: 'x', endProp: 'x2'},\n  yScaleID: {min: 'yMin', max: 'yMax', start: 'bottom', end: 'top', startProp: 'y', endProp: 'y2'}\n};\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import(\"chart.js\").Scale } Scale\n * @typedef { import(\"chart.js\").Point } Point\n * @typedef { import('../../types/element').AnnotationBoxModel } AnnotationBoxModel\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\n * @typedef { import('../../types/options').LineAnnotationOptions } LineAnnotationOptions\n * @typedef { import('../../types/options').PointAnnotationOptions } PointAnnotationOptions\n * @typedef { import('../../types/options').PolygonAnnotationOptions } PolygonAnnotationOptions\n */\n\n/**\n * @param {Scale} scale\n * @param {number|string} value\n * @param {number} fallback\n * @returns {number}\n */\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ? scale.getPixelForValue(value) : fallback;\n}\n\n/**\n * Search the scale defined in chartjs by the axis related to the annotation options key.\n * @param {{ [key: string]: Scale }} scales\n * @param {CoreAnnotationOptions} options\n * @param {string} key\n * @returns {string}\n */\nfunction retrieveScaleID(scales, options, key) {\n  const scaleID = options[key];\n  if (scaleID || key === 'scaleID') {\n    return scaleID;\n  }\n  const axis = key.charAt(0);\n  const axes = Object.values(scales).filter((scale) => scale.axis && scale.axis === axis);\n  if (axes.length) {\n    return axes[0].id;\n  }\n  return axis;\n}\n\n/**\n * @param {Scale} scale\n * @param {{min: number, max: number, start: number, end: number}} options\n * @returns {{start: number, end: number}|undefined}\n */\nfunction getDimensionByScale(scale, options) {\n  if (scale) {\n    const reverse = scale.options.reverse;\n    const start = scaleValue(scale, options.min, reverse ? options.end : options.start);\n    const end = scaleValue(scale, options.max, reverse ? options.start : options.end);\n    return {\n      start,\n      end\n    };\n  }\n}\n\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @returns {Point}\n */\nfunction getChartPoint(chart, options) {\n  const {chartArea, scales} = chart;\n  const xScale = scales[retrieveScaleID(scales, options, 'xScaleID')];\n  const yScale = scales[retrieveScaleID(scales, options, 'yScaleID')];\n  let x = chartArea.width / 2;\n  let y = chartArea.height / 2;\n\n  if (xScale) {\n    x = scaleValue(xScale, options.xValue, xScale.left + xScale.width / 2);\n  }\n\n  if (yScale) {\n    y = scaleValue(yScale, options.yValue, yScale.top + yScale.height / 2);\n  }\n  return {x, y};\n}\n\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @returns {AnnotationBoxModel}\n */\nfunction resolveBoxProperties(chart, options) {\n  const scales = chart.scales;\n  const xScale = scales[retrieveScaleID(scales, options, 'xScaleID')];\n  const yScale = scales[retrieveScaleID(scales, options, 'yScaleID')];\n\n  if (!xScale && !yScale) {\n    return {};\n  }\n\n  let {left: x, right: x2} = xScale || chart.chartArea;\n  let {top: y, bottom: y2} = yScale || chart.chartArea;\n  const xDim = getChartDimensionByScale(xScale, {min: options.xMin, max: options.xMax, start: x, end: x2});\n  x = xDim.start;\n  x2 = xDim.end;\n  const yDim = getChartDimensionByScale(yScale, {min: options.yMin, max: options.yMax, start: y2, end: y});\n  y = yDim.start;\n  y2 = yDim.end;\n\n  return {\n    x,\n    y,\n    x2,\n    y2,\n    width: x2 - x,\n    height: y2 - y,\n    centerX: x + (x2 - x) / 2,\n    centerY: y + (y2 - y) / 2\n  };\n}\n\n/**\n * @param {Chart} chart\n * @param {PointAnnotationOptions|PolygonAnnotationOptions} options\n * @returns {AnnotationBoxModel}\n */\nfunction resolvePointProperties(chart, options) {\n  if (!isBoundToPoint(options)) {\n    const box = resolveBoxProperties(chart, options);\n    let radius = options.radius;\n    if (!radius || isNaN(radius)) {\n      radius = Math.min(box.width, box.height) / 2;\n      options.radius = radius;\n    }\n    const size = radius * 2;\n    const adjustCenterX = box.centerX + options.xAdjust;\n    const adjustCenterY = box.centerY + options.yAdjust;\n    return {\n      x: adjustCenterX - radius,\n      y: adjustCenterY - radius,\n      x2: adjustCenterX + radius,\n      y2: adjustCenterY + radius,\n      centerX: adjustCenterX,\n      centerY: adjustCenterY,\n      width: size,\n      height: size,\n      radius\n    };\n  }\n  return getChartCircle(chart, options);\n}\n/**\n * @param {Chart} chart\n * @param {LineAnnotationOptions} options\n * @returns {AnnotationBoxModel}\n */\nfunction resolveLineProperties(chart, options) {\n  const {scales, chartArea} = chart;\n  const scale = scales[options.scaleID];\n  const area = {x: chartArea.left, y: chartArea.top, x2: chartArea.right, y2: chartArea.bottom};\n\n  if (scale) {\n    resolveFullLineProperties(scale, area, options);\n  } else {\n    resolveLimitedLineProperties(scales, area, options);\n  }\n  return area;\n}\n\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @param {boolean} [centerBased=false]\n * @returns {AnnotationBoxModel}\n */\nfunction resolveBoxAndLabelProperties(chart, options) {\n  const properties = resolveBoxProperties(chart, options);\n  properties.initProperties = initAnimationProperties(chart, properties, options);\n  properties.elements = [{\n    type: 'label',\n    optionScope: 'label',\n    properties: resolveLabelElementProperties$1(chart, properties, options),\n    initProperties: properties.initProperties\n  }];\n  return properties;\n}\n\nfunction getChartCircle(chart, options) {\n  const point = getChartPoint(chart, options);\n  const size = options.radius * 2;\n  return {\n    x: point.x - options.radius + options.xAdjust,\n    y: point.y - options.radius + options.yAdjust,\n    x2: point.x + options.radius + options.xAdjust,\n    y2: point.y + options.radius + options.yAdjust,\n    centerX: point.x + options.xAdjust,\n    centerY: point.y + options.yAdjust,\n    radius: options.radius,\n    width: size,\n    height: size\n  };\n}\n\nfunction getChartDimensionByScale(scale, options) {\n  const result = getDimensionByScale(scale, options) || options;\n  return {\n    start: Math.min(result.start, result.end),\n    end: Math.max(result.start, result.end)\n  };\n}\n\nfunction resolveFullLineProperties(scale, area, options) {\n  const min = scaleValue(scale, options.value, NaN);\n  const max = scaleValue(scale, options.endValue, min);\n  if (scale.isHorizontal()) {\n    area.x = min;\n    area.x2 = max;\n  } else {\n    area.y = min;\n    area.y2 = max;\n  }\n}\n\nfunction resolveLimitedLineProperties(scales, area, options) {\n  for (const scaleId of Object.keys(limitedLineScale)) {\n    const scale = scales[retrieveScaleID(scales, options, scaleId)];\n    if (scale) {\n      const {min, max, start, end, startProp, endProp} = limitedLineScale[scaleId];\n      const dim = getDimensionByScale(scale, {min: options[min], max: options[max], start: scale[start], end: scale[end]});\n      area[startProp] = dim.start;\n      area[endProp] = dim.end;\n    }\n  }\n}\n\nfunction calculateX({properties, options}, labelSize, position, padding) {\n  const {x: start, x2: end, width: size} = properties;\n  return calculatePosition({start, end, size, borderWidth: options.borderWidth}, {\n    position: position.x,\n    padding: {start: padding.left, end: padding.right},\n    adjust: options.label.xAdjust,\n    size: labelSize.width\n  });\n}\n\nfunction calculateY({properties, options}, labelSize, position, padding) {\n  const {y: start, y2: end, height: size} = properties;\n  return calculatePosition({start, end, size, borderWidth: options.borderWidth}, {\n    position: position.y,\n    padding: {start: padding.top, end: padding.bottom},\n    adjust: options.label.yAdjust,\n    size: labelSize.height\n  });\n}\n\nfunction calculatePosition(boxOpts, labelOpts) {\n  const {start, end, borderWidth} = boxOpts;\n  const {position, padding: {start: padStart, end: padEnd}, adjust} = labelOpts;\n  const availableSize = end - borderWidth - start - padStart - padEnd - labelOpts.size;\n  return start + borderWidth / 2 + adjust + getRelativePosition(availableSize, position);\n}\n\nfunction resolveLabelElementProperties$1(chart, properties, options) {\n  const label = options.label;\n  label.backgroundColor = 'transparent';\n  label.callout.display = false;\n  const position = toPosition(label.position);\n  const padding = toPadding(label.padding);\n  const labelSize = measureLabelSize(chart.ctx, label);\n  const x = calculateX({properties, options}, labelSize, position, padding);\n  const y = calculateY({properties, options}, labelSize, position, padding);\n  const width = labelSize.width + padding.width;\n  const height = labelSize.height + padding.height;\n  return {\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n    width,\n    height,\n    centerX: x + width / 2,\n    centerY: y + height / 2,\n    rotation: label.rotation\n  };\n\n}\n\nconst moveHooks = ['enter', 'leave'];\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\n */\n\nconst eventHooks = moveHooks.concat('click');\n\n/**\n * @param {Chart} chart\n * @param {Object} state\n * @param {AnnotationPluginOptions} options\n */\nfunction updateListeners(chart, state, options) {\n  state.listened = loadHooks(options, eventHooks, state.listeners);\n  state.moveListened = false;\n\n  moveHooks.forEach(hook => {\n    if (isFunction(options[hook])) {\n      state.moveListened = true;\n    }\n  });\n\n  if (!state.listened || !state.moveListened) {\n    state.annotations.forEach(scope => {\n      if (!state.listened && isFunction(scope.click)) {\n        state.listened = true;\n      }\n      if (!state.moveListened) {\n        moveHooks.forEach(hook => {\n          if (isFunction(scope[hook])) {\n            state.listened = true;\n            state.moveListened = true;\n          }\n        });\n      }\n    });\n  }\n}\n\n/**\n * @param {Object} state\n * @param {ChartEvent} event\n * @param {AnnotationPluginOptions} options\n * @return {boolean|undefined}\n */\nfunction handleEvent(state, event, options) {\n  if (state.listened) {\n    switch (event.type) {\n    case 'mousemove':\n    case 'mouseout':\n      return handleMoveEvents(state, event, options);\n    case 'click':\n      return handleClickEvents(state, event, options);\n    }\n  }\n}\n\nfunction handleMoveEvents(state, event, options) {\n  if (!state.moveListened) {\n    return;\n  }\n\n  let elements;\n\n  if (event.type === 'mousemove') {\n    elements = getElements(state.visibleElements, event, options.interaction);\n  } else {\n    elements = [];\n  }\n\n  const previous = state.hovered;\n  state.hovered = elements;\n\n  const context = {state, event};\n  let changed = dispatchMoveEvents(context, 'leave', previous, elements);\n  return dispatchMoveEvents(context, 'enter', elements, previous) || changed;\n}\n\nfunction dispatchMoveEvents({state, event}, hook, elements, checkElements) {\n  let changed;\n  for (const element of elements) {\n    if (checkElements.indexOf(element) < 0) {\n      changed = dispatchEvent(element.options[hook] || state.listeners[hook], element, event) || changed;\n    }\n  }\n  return changed;\n}\n\nfunction handleClickEvents(state, event, options) {\n  const listeners = state.listeners;\n  const elements = getElements(state.visibleElements, event, options.interaction);\n  let changed;\n  for (const element of elements) {\n    changed = dispatchEvent(element.options.click || listeners.click, element, event) || changed;\n  }\n  return changed;\n}\n\nfunction dispatchEvent(handler, element, event) {\n  return callback(handler, [element.$context, event]) === true;\n}\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */\n\nconst elementHooks = ['afterDraw', 'beforeDraw'];\n\n/**\n * @param {Chart} chart\n * @param {Object} state\n * @param {AnnotationPluginOptions} options\n */\nfunction updateHooks(chart, state, options) {\n  const visibleElements = state.visibleElements;\n  state.hooked = loadHooks(options, elementHooks, state.hooks);\n\n  if (!state.hooked) {\n    visibleElements.forEach(scope => {\n      if (!state.hooked) {\n        elementHooks.forEach(hook => {\n          if (isFunction(scope.options[hook])) {\n            state.hooked = true;\n          }\n        });\n      }\n    });\n  }\n}\n\n/**\n * @param {Object} state\n * @param {AnnotationElement} element\n * @param {string} hook\n */\nfunction invokeHook(state, element, hook) {\n  if (state.hooked) {\n    const callbackHook = element.options[hook] || state.hooks[hook];\n    return callback(callbackHook, [element.$context]);\n  }\n}\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import(\"chart.js\").Scale } Scale\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\n */\n\n/**\n * @param {Chart} chart\n * @param {Scale} scale\n * @param {CoreAnnotationOptions[]} annotations\n */\nfunction adjustScaleRange(chart, scale, annotations) {\n  const range = getScaleLimits(chart.scales, scale, annotations);\n  let changed = changeScaleLimit(scale, range, 'min', 'suggestedMin');\n  changed = changeScaleLimit(scale, range, 'max', 'suggestedMax') || changed;\n  if (changed && isFunction(scale.handleTickRangeOptions)) {\n    scale.handleTickRangeOptions();\n  }\n}\n\n/**\n * @param {CoreAnnotationOptions[]} annotations\n * @param {{ [key: string]: Scale }} scales\n */\nfunction verifyScaleOptions(annotations, scales) {\n  for (const annotation of annotations) {\n    verifyScaleIDs(annotation, scales);\n  }\n}\n\nfunction changeScaleLimit(scale, range, limit, suggestedLimit) {\n  if (isFinite(range[limit]) && !scaleLimitDefined(scale.options, limit, suggestedLimit)) {\n    const changed = scale[limit] !== range[limit];\n    scale[limit] = range[limit];\n    return changed;\n  }\n}\n\nfunction scaleLimitDefined(scaleOptions, limit, suggestedLimit) {\n  return defined(scaleOptions[limit]) || defined(scaleOptions[suggestedLimit]);\n}\n\nfunction verifyScaleIDs(annotation, scales) {\n  for (const key of ['scaleID', 'xScaleID', 'yScaleID']) {\n    const scaleID = retrieveScaleID(scales, annotation, key);\n    if (scaleID && !scales[scaleID] && verifyProperties(annotation, key)) {\n      console.warn(`No scale found with id '${scaleID}' for annotation '${annotation.id}'`);\n    }\n  }\n}\n\nfunction verifyProperties(annotation, key) {\n  if (key === 'scaleID') {\n    return true;\n  }\n  const axis = key.charAt(0);\n  for (const prop of ['Min', 'Max', 'Value']) {\n    if (defined(annotation[axis + prop])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction getScaleLimits(scales, scale, annotations) {\n  const axis = scale.axis;\n  const scaleID = scale.id;\n  const scaleIDOption = axis + 'ScaleID';\n  const limits = {\n    min: valueOrDefault(scale.min, Number.NEGATIVE_INFINITY),\n    max: valueOrDefault(scale.max, Number.POSITIVE_INFINITY)\n  };\n  for (const annotation of annotations) {\n    if (annotation.scaleID === scaleID) {\n      updateLimits(annotation, scale, ['value', 'endValue'], limits);\n    } else if (retrieveScaleID(scales, annotation, scaleIDOption) === scaleID) {\n      updateLimits(annotation, scale, [axis + 'Min', axis + 'Max', axis + 'Value'], limits);\n    }\n  }\n  return limits;\n}\n\nfunction updateLimits(annotation, scale, props, limits) {\n  for (const prop of props) {\n    const raw = annotation[prop];\n    if (defined(raw)) {\n      const value = scale.parse(raw);\n      limits.min = Math.min(limits.min, value);\n      limits.max = Math.max(limits.max, value);\n    }\n  }\n}\n\nclass BoxAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const {x, y} = rotated({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));\n    return inBoxRange({x, y}, this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis, this.options);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), this.options.rotation);\n    drawBox(ctx, this, this.options);\n    ctx.restore();\n  }\n\n  get label() {\n    return this.elements && this.elements[0];\n  }\n\n  resolveElementProperties(chart, options) {\n    return resolveBoxAndLabelProperties(chart, options);\n  }\n}\n\nBoxAnnotation.id = 'boxAnnotation';\n\nBoxAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderRadius: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  init: undefined,\n  hitTolerance: 0,\n  label: {\n    backgroundColor: 'transparent',\n    borderWidth: 0,\n    callout: {\n      display: false\n    },\n    color: 'black',\n    content: null,\n    display: false,\n    drawTime: undefined,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    height: undefined,\n    hitTolerance: undefined,\n    opacity: undefined,\n    padding: 6,\n    position: 'center',\n    rotation: undefined,\n    textAlign: 'start',\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    width: undefined,\n    xAdjust: 0,\n    yAdjust: 0,\n    z: undefined\n  },\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\n\nBoxAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nBoxAnnotation.descriptors = {\n  label: {\n    _fallback: true\n  }\n};\n\nclass DoughnutLabelAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    return inLabelRange(\n      {x: mouseX, y: mouseY},\n      {rect: this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), center: this.getCenterPoint(useFinalPosition)},\n      axis,\n      {rotation: this.rotation, borderWidth: 0, hitTolerance: this.options.hitTolerance}\n    );\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const options = this.options;\n    if (!options.display || !options.content) {\n      return;\n    }\n    drawBackground(ctx, this);\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), this.rotation);\n    drawLabel(ctx, this, options, this._fitRatio);\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    const meta = getDatasetMeta(chart, options);\n    if (!meta) {\n      return {};\n    }\n    const {controllerMeta, point, radius} = getControllerMeta(chart, options, meta);\n    let labelSize = measureLabelSize(chart.ctx, options);\n    const _fitRatio = getFitRatio(labelSize, radius);\n    if (shouldFit(options, _fitRatio)) {\n      labelSize = {width: labelSize.width * _fitRatio, height: labelSize.height * _fitRatio};\n    }\n    const {position, xAdjust, yAdjust} = options;\n    const boxSize = measureLabelRectangle(point, labelSize, {borderWidth: 0, position, xAdjust, yAdjust});\n    return {\n      initProperties: initAnimationProperties(chart, boxSize, options),\n      ...boxSize,\n      ...controllerMeta,\n      rotation: options.rotation,\n      _fitRatio\n    };\n  }\n}\n\nDoughnutLabelAnnotation.id = 'doughnutLabelAnnotation';\n\nDoughnutLabelAnnotation.defaults = {\n  autoFit: true,\n  autoHide: true,\n  backgroundColor: 'transparent',\n  backgroundShadowColor: 'transparent',\n  borderColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderShadowColor: 'transparent',\n  borderWidth: 0,\n  color: 'black',\n  content: null,\n  display: true,\n  font: {\n    family: undefined,\n    lineHeight: undefined,\n    size: undefined,\n    style: undefined,\n    weight: undefined\n  },\n  height: undefined,\n  hitTolerance: 0,\n  init: undefined,\n  opacity: undefined,\n  position: 'center',\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  spacing: 1,\n  textAlign: 'center',\n  textStrokeColor: undefined,\n  textStrokeWidth: 0,\n  width: undefined,\n  xAdjust: 0,\n  yAdjust: 0\n};\n\nDoughnutLabelAnnotation.defaultRoutes = {\n};\n\nfunction getDatasetMeta(chart, options) {\n  return chart.getSortedVisibleDatasetMetas().reduce(function(result, value) {\n    const controller = value.controller;\n    if (controller instanceof DoughnutController &&\n      isControllerVisible(chart, options, value.data) &&\n      (!result || controller.innerRadius < result.controller.innerRadius) &&\n      controller.options.circumference >= 90) {\n      return value;\n    }\n    return result;\n  }, undefined);\n}\n\nfunction isControllerVisible(chart, options, elements) {\n  if (!options.autoHide) {\n    return true;\n  }\n  for (let i = 0; i < elements.length; i++) {\n    if (!elements[i].hidden && chart.getDataVisibility(i)) {\n      return true;\n    }\n  }\n}\n\nfunction getControllerMeta({chartArea}, options, meta) {\n  const {left, top, right, bottom} = chartArea;\n  const {innerRadius, offsetX, offsetY} = meta.controller;\n  const x = (left + right) / 2 + offsetX;\n  const y = (top + bottom) / 2 + offsetY;\n  const square = {\n    left: Math.max(x - innerRadius, left),\n    right: Math.min(x + innerRadius, right),\n    top: Math.max(y - innerRadius, top),\n    bottom: Math.min(y + innerRadius, bottom)\n  };\n  const point = {\n    x: (square.left + square.right) / 2,\n    y: (square.top + square.bottom) / 2\n  };\n  const space = options.spacing + options.borderWidth / 2;\n  const _radius = innerRadius - space;\n  const _counterclockwise = point.y > y;\n  const side = _counterclockwise ? top + space : bottom - space;\n  const angles = getAngles(side, x, y, _radius);\n  const controllerMeta = {\n    _centerX: x,\n    _centerY: y,\n    _radius,\n    _counterclockwise,\n    ...angles\n  };\n  return {\n    controllerMeta,\n    point,\n    radius: Math.min(innerRadius, Math.min(square.right - square.left, square.bottom - square.top) / 2)\n  };\n}\n\nfunction getFitRatio({width, height}, radius) {\n  const hypo = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\n  return (radius * 2) / hypo;\n}\n\nfunction getAngles(y, centerX, centerY, radius) {\n  const yk2 = Math.pow(centerY - y, 2);\n  const r2 = Math.pow(radius, 2);\n  const b = centerX * -2;\n  const c = Math.pow(centerX, 2) + yk2 - r2;\n  const delta = Math.pow(b, 2) - (4 * c);\n  if (delta <= 0) {\n    return {\n      _startAngle: 0,\n      _endAngle: TAU\n    };\n  }\n  const start = (-b - Math.sqrt(delta)) / 2;\n  const end = (-b + Math.sqrt(delta)) / 2;\n  return {\n    _startAngle: getAngleFromPoint({x: centerX, y: centerY}, {x: start, y}).angle,\n    _endAngle: getAngleFromPoint({x: centerX, y: centerY}, {x: end, y}).angle\n  };\n}\n\nfunction drawBackground(ctx, element) {\n  const {_centerX, _centerY, _radius, _startAngle, _endAngle, _counterclockwise, options} = element;\n  ctx.save();\n  const stroke = setBorderStyle(ctx, options);\n  ctx.fillStyle = options.backgroundColor;\n  ctx.beginPath();\n  ctx.arc(_centerX, _centerY, _radius, _startAngle, _endAngle, _counterclockwise);\n  ctx.closePath();\n  ctx.fill();\n  if (stroke) {\n    ctx.stroke();\n  }\n  ctx.restore();\n}\n\nclass LabelAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    return inLabelRange(\n      {x: mouseX, y: mouseY},\n      {rect: this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), center: this.getCenterPoint(useFinalPosition)},\n      axis,\n      {rotation: this.rotation, borderWidth: this.options.borderWidth, hitTolerance: this.options.hitTolerance}\n    );\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const options = this.options;\n    const visible = !defined(this._visible) || this._visible;\n    if (!options.display || !options.content || !visible) {\n      return;\n    }\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), this.rotation);\n    drawCallout(ctx, this);\n    drawBox(ctx, this, options);\n    drawLabel(ctx, getLabelSize(this), options);\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    let point;\n    if (!isBoundToPoint(options)) {\n      const {centerX, centerY} = resolveBoxProperties(chart, options);\n      point = {x: centerX, y: centerY};\n    } else {\n      point = getChartPoint(chart, options);\n    }\n    const padding = toPadding(options.padding);\n    const labelSize = measureLabelSize(chart.ctx, options);\n    const boxSize = measureLabelRectangle(point, labelSize, options, padding);\n    return {\n      initProperties: initAnimationProperties(chart, boxSize, options),\n      pointX: point.x,\n      pointY: point.y,\n      ...boxSize,\n      rotation: options.rotation\n    };\n  }\n}\n\nLabelAnnotation.id = 'labelAnnotation';\n\nLabelAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundColor: 'transparent',\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderRadius: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 0,\n  callout: {\n    borderCapStyle: 'butt',\n    borderColor: undefined,\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderWidth: 1,\n    display: false,\n    margin: 5,\n    position: 'auto',\n    side: 5,\n    start: '50%',\n  },\n  color: 'black',\n  content: null,\n  display: true,\n  font: {\n    family: undefined,\n    lineHeight: undefined,\n    size: undefined,\n    style: undefined,\n    weight: undefined\n  },\n  height: undefined,\n  hitTolerance: 0,\n  init: undefined,\n  opacity: undefined,\n  padding: 6,\n  position: 'center',\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  textAlign: 'center',\n  textStrokeColor: undefined,\n  textStrokeWidth: 0,\n  width: undefined,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\n\nLabelAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\n\nfunction getLabelSize({x, y, width, height, options}) {\n  const hBorderWidth = options.borderWidth / 2;\n  const padding = toPadding(options.padding);\n  return {\n    x: x + padding.left + hBorderWidth,\n    y: y + padding.top + hBorderWidth,\n    width: width - padding.left - padding.right - options.borderWidth,\n    height: height - padding.top - padding.bottom - options.borderWidth\n  };\n}\n\nconst pointInLine = (p1, p2, t) => ({x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y)});\nconst interpolateX = (y, p1, p2) => pointInLine(p1, p2, Math.abs((y - p1.y) / (p2.y - p1.y))).x;\nconst interpolateY = (x, p1, p2) => pointInLine(p1, p2, Math.abs((x - p1.x) / (p2.x - p1.x))).y;\nconst sqr = v => v * v;\nconst rangeLimit = (mouseX, mouseY, {x, y, x2, y2}, axis) => axis === 'y' ? {start: Math.min(y, y2), end: Math.max(y, y2), value: mouseY} : {start: Math.min(x, x2), end: Math.max(x, x2), value: mouseX};\n// http://www.independent-software.com/determining-coordinates-on-a-html-canvas-bezier-curve.html\nconst coordInCurve = (start, cp, end, t) => (1 - t) * (1 - t) * start + 2 * (1 - t) * t * cp + t * t * end;\nconst pointInCurve = (start, cp, end, t) => ({x: coordInCurve(start.x, cp.x, end.x, t), y: coordInCurve(start.y, cp.y, end.y, t)});\nconst coordAngleInCurve = (start, cp, end, t) => 2 * (1 - t) * (cp - start) + 2 * t * (end - cp);\nconst angleInCurve = (start, cp, end, t) => -Math.atan2(coordAngleInCurve(start.x, cp.x, end.x, t), coordAngleInCurve(start.y, cp.y, end.y, t)) + 0.5 * PI;\n\nclass LineAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const hitSize = (this.options.borderWidth + this.options.hitTolerance) / 2;\n    if (axis !== 'x' && axis !== 'y') {\n      const point = {mouseX, mouseY};\n      const {path, ctx} = this;\n      if (path) {\n        setBorderStyle(ctx, this.options);\n        ctx.lineWidth += this.options.hitTolerance;\n        const {chart} = this.$context;\n        const mx = mouseX * chart.currentDevicePixelRatio;\n        const my = mouseY * chart.currentDevicePixelRatio;\n        const result = ctx.isPointInStroke(path, mx, my) || isOnLabel(this, point, useFinalPosition);\n        ctx.restore();\n        return result;\n      }\n      const epsilon = sqr(hitSize);\n      return intersects(this, point, epsilon, useFinalPosition) || isOnLabel(this, point, useFinalPosition);\n    }\n    return inAxisRange(this, {mouseX, mouseY}, axis, {hitSize, useFinalPosition});\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const {x, y, x2, y2, cp, options} = this;\n\n    ctx.save();\n    if (!setBorderStyle(ctx, options)) {\n      // no border width, then line is not drawn\n      return ctx.restore();\n    }\n    setShadowStyle(ctx, options);\n\n    const length = Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2));\n    if (options.curve && cp) {\n      drawCurve(ctx, this, cp, length);\n      return ctx.restore();\n    }\n    const {startOpts, endOpts, startAdjust, endAdjust} = getArrowHeads(this);\n    const angle = Math.atan2(y2 - y, x2 - x);\n    ctx.translate(x, y);\n    ctx.rotate(angle);\n    ctx.beginPath();\n    ctx.moveTo(0 + startAdjust, 0);\n    ctx.lineTo(length - endAdjust, 0);\n    ctx.shadowColor = options.borderShadowColor;\n    ctx.stroke();\n    drawArrowHead(ctx, 0, startAdjust, startOpts);\n    drawArrowHead(ctx, length, -endAdjust, endOpts);\n    ctx.restore();\n  }\n\n  get label() {\n    return this.elements && this.elements[0];\n  }\n\n  resolveElementProperties(chart, options) {\n    const area = resolveLineProperties(chart, options);\n    const {x, y, x2, y2} = area;\n    const inside = isLineInArea(area, chart.chartArea);\n    const properties = inside\n      ? limitLineToArea({x, y}, {x: x2, y: y2}, chart.chartArea)\n      : {x, y, x2, y2, width: Math.abs(x2 - x), height: Math.abs(y2 - y)};\n    properties.centerX = (x2 + x) / 2;\n    properties.centerY = (y2 + y) / 2;\n    properties.initProperties = initAnimationProperties(chart, properties, options);\n    if (options.curve) {\n      const p1 = {x: properties.x, y: properties.y};\n      const p2 = {x: properties.x2, y: properties.y2};\n      properties.cp = getControlPoint(properties, options, distanceBetweenPoints(p1, p2));\n    }\n    const labelProperties = resolveLabelElementProperties(chart, properties, options.label);\n    // additonal prop to manage zoom/pan\n    labelProperties._visible = inside;\n\n    properties.elements = [{\n      type: 'label',\n      optionScope: 'label',\n      properties: labelProperties,\n      initProperties: properties.initProperties\n    }];\n    return properties;\n  }\n}\n\nLineAnnotation.id = 'lineAnnotation';\n\nconst arrowHeadsDefaults = {\n  backgroundColor: undefined,\n  backgroundShadowColor: undefined,\n  borderColor: undefined,\n  borderDash: undefined,\n  borderDashOffset: undefined,\n  borderShadowColor: undefined,\n  borderWidth: undefined,\n  display: undefined,\n  fill: undefined,\n  length: undefined,\n  shadowBlur: undefined,\n  shadowOffsetX: undefined,\n  shadowOffsetY: undefined,\n  width: undefined\n};\n\nLineAnnotation.defaults = {\n  adjustScaleRange: true,\n  arrowHeads: {\n    display: false,\n    end: Object.assign({}, arrowHeadsDefaults),\n    fill: false,\n    length: 12,\n    start: Object.assign({}, arrowHeadsDefaults),\n    width: 6\n  },\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 2,\n  curve: false,\n  controlPoint: {\n    y: '-50%'\n  },\n  display: true,\n  endValue: undefined,\n  init: undefined,\n  hitTolerance: 0,\n  label: {\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    backgroundShadowColor: 'transparent',\n    borderCapStyle: 'butt',\n    borderColor: 'black',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderRadius: 6,\n    borderShadowColor: 'transparent',\n    borderWidth: 0,\n    callout: Object.assign({}, LabelAnnotation.defaults.callout),\n    color: '#fff',\n    content: null,\n    display: false,\n    drawTime: undefined,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    height: undefined,\n    hitTolerance: undefined,\n    opacity: undefined,\n    padding: 6,\n    position: 'center',\n    rotation: 0,\n    shadowBlur: 0,\n    shadowOffsetX: 0,\n    shadowOffsetY: 0,\n    textAlign: 'center',\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    width: undefined,\n    xAdjust: 0,\n    yAdjust: 0,\n    z: undefined\n  },\n  scaleID: undefined,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  value: undefined,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\n\nLineAnnotation.descriptors = {\n  arrowHeads: {\n    start: {\n      _fallback: true\n    },\n    end: {\n      _fallback: true\n    },\n    _fallback: true\n  }\n};\n\nLineAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\n\nfunction inAxisRange(element, {mouseX, mouseY}, axis, {hitSize, useFinalPosition}) {\n  const limit = rangeLimit(mouseX, mouseY, element.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis);\n  return inLimit(limit, hitSize) || isOnLabel(element, {mouseX, mouseY}, useFinalPosition, axis);\n}\n\nfunction isLineInArea({x, y, x2, y2}, {top, right, bottom, left}) {\n  return !(\n    (x < left && x2 < left) ||\n    (x > right && x2 > right) ||\n    (y < top && y2 < top) ||\n    (y > bottom && y2 > bottom)\n  );\n}\n\nfunction limitPointToArea({x, y}, p2, {top, right, bottom, left}) {\n  if (x < left) {\n    y = interpolateY(left, {x, y}, p2);\n    x = left;\n  }\n  if (x > right) {\n    y = interpolateY(right, {x, y}, p2);\n    x = right;\n  }\n  if (y < top) {\n    x = interpolateX(top, {x, y}, p2);\n    y = top;\n  }\n  if (y > bottom) {\n    x = interpolateX(bottom, {x, y}, p2);\n    y = bottom;\n  }\n  return {x, y};\n}\n\nfunction limitLineToArea(p1, p2, area) {\n  const {x, y} = limitPointToArea(p1, p2, area);\n  const {x: x2, y: y2} = limitPointToArea(p2, p1, area);\n  return {x, y, x2, y2, width: Math.abs(x2 - x), height: Math.abs(y2 - y)};\n}\n\nfunction intersects(element, {mouseX, mouseY}, epsilon = EPSILON, useFinalPosition) {\n  // Adapted from https://stackoverflow.com/a/6853926/25507\n  const {x: x1, y: y1, x2, y2} = element.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition);\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const lenSq = sqr(dx) + sqr(dy);\n  const t = lenSq === 0 ? -1 : ((mouseX - x1) * dx + (mouseY - y1) * dy) / lenSq;\n\n  let xx, yy;\n  if (t < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (t > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + t * dx;\n    yy = y1 + t * dy;\n  }\n  return (sqr(mouseX - xx) + sqr(mouseY - yy)) <= epsilon;\n}\n\nfunction isOnLabel(element, {mouseX, mouseY}, useFinalPosition, axis) {\n  const label = element.label;\n  return label.options.display && label.inRange(mouseX, mouseY, axis, useFinalPosition);\n}\n\nfunction resolveLabelElementProperties(chart, properties, options) {\n  const borderWidth = options.borderWidth;\n  const padding = toPadding(options.padding);\n  const textSize = measureLabelSize(chart.ctx, options);\n  const width = textSize.width + padding.width + borderWidth;\n  const height = textSize.height + padding.height + borderWidth;\n  return calculateLabelPosition(properties, options, {width, height, padding}, chart.chartArea);\n}\n\nfunction calculateAutoRotation(properties) {\n  const {x, y, x2, y2} = properties;\n  const rotation = Math.atan2(y2 - y, x2 - x);\n  // Flip the rotation if it goes > PI/2 or < -PI/2, so label stays upright\n  return rotation > PI / 2 ? rotation - PI : rotation < PI / -2 ? rotation + PI : rotation;\n}\n\nfunction calculateLabelPosition(properties, label, sizes, chartArea) {\n  const {width, height, padding} = sizes;\n  const {xAdjust, yAdjust} = label;\n  const p1 = {x: properties.x, y: properties.y};\n  const p2 = {x: properties.x2, y: properties.y2};\n  const rotation = label.rotation === 'auto' ? calculateAutoRotation(properties) : toRadians(label.rotation);\n  const size = rotatedSize(width, height, rotation);\n  const t = calculateT(properties, label, {labelSize: size, padding}, chartArea);\n  const pt = properties.cp ? pointInCurve(p1, properties.cp, p2, t) : pointInLine(p1, p2, t);\n  const xCoordinateSizes = {size: size.w, min: chartArea.left, max: chartArea.right, padding: padding.left};\n  const yCoordinateSizes = {size: size.h, min: chartArea.top, max: chartArea.bottom, padding: padding.top};\n  const centerX = adjustLabelCoordinate(pt.x, xCoordinateSizes) + xAdjust;\n  const centerY = adjustLabelCoordinate(pt.y, yCoordinateSizes) + yAdjust;\n  return {\n    x: centerX - (width / 2),\n    y: centerY - (height / 2),\n    x2: centerX + (width / 2),\n    y2: centerY + (height / 2),\n    centerX,\n    centerY,\n    pointX: pt.x,\n    pointY: pt.y,\n    width,\n    height,\n    rotation: toDegrees(rotation)\n  };\n}\n\nfunction rotatedSize(width, height, rotation) {\n  const cos = Math.cos(rotation);\n  const sin = Math.sin(rotation);\n  return {\n    w: Math.abs(width * cos) + Math.abs(height * sin),\n    h: Math.abs(width * sin) + Math.abs(height * cos)\n  };\n}\n\nfunction calculateT(properties, label, sizes, chartArea) {\n  let t;\n  const space = spaceAround(properties, chartArea);\n  if (label.position === 'start') {\n    t = calculateTAdjust({w: properties.x2 - properties.x, h: properties.y2 - properties.y}, sizes, label, space);\n  } else if (label.position === 'end') {\n    t = 1 - calculateTAdjust({w: properties.x - properties.x2, h: properties.y - properties.y2}, sizes, label, space);\n  } else {\n    t = getRelativePosition(1, label.position);\n  }\n  return t;\n}\n\nfunction calculateTAdjust(lineSize, sizes, label, space) {\n  const {labelSize, padding} = sizes;\n  const lineW = lineSize.w * space.dx;\n  const lineH = lineSize.h * space.dy;\n  const x = (lineW > 0) && ((labelSize.w / 2 + padding.left - space.x) / lineW);\n  const y = (lineH > 0) && ((labelSize.h / 2 + padding.top - space.y) / lineH);\n  return clamp(Math.max(x, y), 0, 0.25);\n}\n\nfunction spaceAround(properties, chartArea) {\n  const {x, x2, y, y2} = properties;\n  const t = Math.min(y, y2) - chartArea.top;\n  const l = Math.min(x, x2) - chartArea.left;\n  const b = chartArea.bottom - Math.max(y, y2);\n  const r = chartArea.right - Math.max(x, x2);\n  return {\n    x: Math.min(l, r),\n    y: Math.min(t, b),\n    dx: l <= r ? 1 : -1,\n    dy: t <= b ? 1 : -1\n  };\n}\n\nfunction adjustLabelCoordinate(coordinate, labelSizes) {\n  const {size, min, max, padding} = labelSizes;\n  const halfSize = size / 2;\n  if (size > max - min) {\n    // if it does not fit, display as much as possible\n    return (max + min) / 2;\n  }\n  if (min >= (coordinate - padding - halfSize)) {\n    coordinate = min + padding + halfSize;\n  }\n  if (max <= (coordinate + padding + halfSize)) {\n    coordinate = max - padding - halfSize;\n  }\n  return coordinate;\n}\n\nfunction getArrowHeads(line) {\n  const options = line.options;\n  const arrowStartOpts = options.arrowHeads && options.arrowHeads.start;\n  const arrowEndOpts = options.arrowHeads && options.arrowHeads.end;\n  return {\n    startOpts: arrowStartOpts,\n    endOpts: arrowEndOpts,\n    startAdjust: getLineAdjust(line, arrowStartOpts),\n    endAdjust: getLineAdjust(line, arrowEndOpts)\n  };\n}\n\nfunction getLineAdjust(line, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.display) {\n    return 0;\n  }\n  const {length, width} = arrowOpts;\n  const adjust = line.options.borderWidth / 2;\n  const p1 = {x: length, y: width + adjust};\n  const p2 = {x: 0, y: adjust};\n  return Math.abs(interpolateX(0, p1, p2));\n}\n\nfunction drawArrowHead(ctx, offset, adjust, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.display) {\n    return;\n  }\n  const {length, width, fill, backgroundColor, borderColor} = arrowOpts;\n  const arrowOffsetX = Math.abs(offset - length) + adjust;\n  ctx.beginPath();\n  setShadowStyle(ctx, arrowOpts);\n  setBorderStyle(ctx, arrowOpts);\n  ctx.moveTo(arrowOffsetX, -width);\n  ctx.lineTo(offset + adjust, 0);\n  ctx.lineTo(arrowOffsetX, width);\n  if (fill === true) {\n    ctx.fillStyle = backgroundColor || borderColor;\n    ctx.closePath();\n    ctx.fill();\n    ctx.shadowColor = 'transparent';\n  } else {\n    ctx.shadowColor = arrowOpts.borderShadowColor;\n  }\n  ctx.stroke();\n}\n\nfunction getControlPoint(properties, options, distance) {\n  const {x, y, x2, y2, centerX, centerY} = properties;\n  const angle = Math.atan2(y2 - y, x2 - x);\n  const cp = toPosition(options.controlPoint, 0);\n  const point = {\n    x: centerX + getSize(distance, cp.x, false),\n    y: centerY + getSize(distance, cp.y, false)\n  };\n  return rotated(point, {x: centerX, y: centerY}, angle);\n}\n\nfunction drawArrowHeadOnCurve(ctx, {x, y}, {angle, adjust}, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.display) {\n    return;\n  }\n  ctx.save();\n  ctx.translate(x, y);\n  ctx.rotate(angle);\n  drawArrowHead(ctx, 0, -adjust, arrowOpts);\n  ctx.restore();\n}\n\nfunction drawCurve(ctx, element, cp, length) {\n  const {x, y, x2, y2, options} = element;\n  const {startOpts, endOpts, startAdjust, endAdjust} = getArrowHeads(element);\n  const p1 = {x, y};\n  const p2 = {x: x2, y: y2};\n  const startAngle = angleInCurve(p1, cp, p2, 0);\n  const endAngle = angleInCurve(p1, cp, p2, 1) - PI;\n  const ps = pointInCurve(p1, cp, p2, startAdjust / length);\n  const pe = pointInCurve(p1, cp, p2, 1 - endAdjust / length);\n\n  const path = new Path2D();\n  ctx.beginPath();\n  path.moveTo(ps.x, ps.y);\n  path.quadraticCurveTo(cp.x, cp.y, pe.x, pe.y);\n  ctx.shadowColor = options.borderShadowColor;\n  ctx.stroke(path);\n  element.path = path;\n  element.ctx = ctx;\n  drawArrowHeadOnCurve(ctx, ps, {angle: startAngle, adjust: startAdjust}, startOpts);\n  drawArrowHeadOnCurve(ctx, pe, {angle: endAngle, adjust: endAdjust}, endOpts);\n}\n\nclass EllipseAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const rotation = this.options.rotation;\n    const hitSize = (this.options.borderWidth + this.options.hitTolerance) / 2;\n    if (axis !== 'x' && axis !== 'y') {\n      return pointInEllipse({x: mouseX, y: mouseY}, this.getProps(['width', 'height', 'centerX', 'centerY'], useFinalPosition), rotation, hitSize);\n    }\n    const {x, y, x2, y2} = this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition);\n    const limit = axis === 'y' ? {start: y, end: y2} : {start: x, end: x2};\n    const rotatedPoint = rotated({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), toRadians(-rotation));\n    return rotatedPoint[axis] >= limit.start - hitSize - EPSILON && rotatedPoint[axis] <= limit.end + hitSize + EPSILON;\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const {width, height, centerX, centerY, options} = this;\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), options.rotation);\n    setShadowStyle(ctx, this.options);\n    ctx.beginPath();\n    ctx.fillStyle = options.backgroundColor;\n    const stroke = setBorderStyle(ctx, options);\n    ctx.ellipse(centerX, centerY, height / 2, width / 2, PI / 2, 0, 2 * PI);\n    ctx.fill();\n    if (stroke) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  get label() {\n    return this.elements && this.elements[0];\n  }\n\n  resolveElementProperties(chart, options) {\n    return resolveBoxAndLabelProperties(chart, options);\n  }\n\n}\n\nEllipseAnnotation.id = 'ellipseAnnotation';\n\nEllipseAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  hitTolerance: 0,\n  init: undefined,\n  label: Object.assign({}, BoxAnnotation.defaults.label),\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\n\nEllipseAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nEllipseAnnotation.descriptors = {\n  label: {\n    _fallback: true\n  }\n};\n\nfunction pointInEllipse(p, ellipse, rotation, hitSize) {\n  const {width, height, centerX, centerY} = ellipse;\n  const xRadius = width / 2;\n  const yRadius = height / 2;\n\n  if (xRadius <= 0 || yRadius <= 0) {\n    return false;\n  }\n  // https://stackoverflow.com/questions/7946187/point-and-ellipse-rotated-position-test-algorithm\n  const angle = toRadians(rotation || 0);\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n  const a = Math.pow(cosAngle * (p.x - centerX) + sinAngle * (p.y - centerY), 2);\n  const b = Math.pow(sinAngle * (p.x - centerX) - cosAngle * (p.y - centerY), 2);\n  return (a / Math.pow(xRadius + hitSize, 2)) + (b / Math.pow(yRadius + hitSize, 2)) <= 1.0001;\n}\n\nclass PointAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const {x, y, x2, y2, width} = this.getProps(['x', 'y', 'x2', 'y2', 'width'], useFinalPosition);\n    const hitSize = (this.options.borderWidth + this.options.hitTolerance) / 2;\n    if (axis !== 'x' && axis !== 'y') {\n      return inPointRange({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), width / 2, hitSize);\n    }\n    const limit = axis === 'y' ? {start: y, end: y2, value: mouseY} : {start: x, end: x2, value: mouseX};\n    return inLimit(limit, hitSize);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const options = this.options;\n    const borderWidth = options.borderWidth;\n    if (options.radius < 0.1) {\n      return;\n    }\n    ctx.save();\n    ctx.fillStyle = options.backgroundColor;\n    setShadowStyle(ctx, options);\n    const stroke = setBorderStyle(ctx, options);\n    drawPoint(ctx, this, this.centerX, this.centerY);\n    if (stroke && !isImageOrCanvas(options.pointStyle)) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n    options.borderWidth = borderWidth;\n  }\n\n  resolveElementProperties(chart, options) {\n    const properties = resolvePointProperties(chart, options);\n    properties.initProperties = initAnimationProperties(chart, properties, options);\n    return properties;\n  }\n}\n\nPointAnnotation.id = 'pointAnnotation';\n\nPointAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  hitTolerance: 0,\n  init: undefined,\n  pointStyle: 'circle',\n  radius: 10,\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\n\nPointAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nclass PolygonAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    if (axis !== 'x' && axis !== 'y') {\n      return this.options.radius >= 0.1 && this.elements.length > 1 && pointIsInPolygon(this.elements, mouseX, mouseY, useFinalPosition);\n    }\n    const rotatedPoint = rotated({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));\n    const axisPoints = this.elements.map((point) => axis === 'y' ? point.bY : point.bX);\n    const start = Math.min(...axisPoints);\n    const end = Math.max(...axisPoints);\n    return rotatedPoint[axis] >= start && rotatedPoint[axis] <= end;\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const {elements, options} = this;\n    ctx.save();\n    ctx.beginPath();\n    ctx.fillStyle = options.backgroundColor;\n    setShadowStyle(ctx, options);\n    const stroke = setBorderStyle(ctx, options);\n    let first = true;\n    for (const el of elements) {\n      if (first) {\n        ctx.moveTo(el.x, el.y);\n        first = false;\n      } else {\n        ctx.lineTo(el.x, el.y);\n      }\n    }\n    ctx.closePath();\n    ctx.fill();\n    // If no border, don't draw it\n    if (stroke) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    const properties = resolvePointProperties(chart, options);\n    const {sides, rotation} = options;\n    const elements = [];\n    const angle = (2 * PI) / sides;\n    let rad = rotation * RAD_PER_DEG;\n    for (let i = 0; i < sides; i++, rad += angle) {\n      const elProps = buildPointElement(properties, options, rad);\n      elProps.initProperties = initAnimationProperties(chart, properties, options);\n      elements.push(elProps);\n    }\n    properties.elements = elements;\n    return properties;\n  }\n}\n\nPolygonAnnotation.id = 'polygonAnnotation';\n\nPolygonAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  hitTolerance: 0,\n  init: undefined,\n  point: {\n    radius: 0\n  },\n  radius: 10,\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  sides: 3,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\n\nPolygonAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nfunction buildPointElement({centerX, centerY}, {radius, borderWidth, hitTolerance}, rad) {\n  const hitSize = (borderWidth + hitTolerance) / 2;\n  const sin = Math.sin(rad);\n  const cos = Math.cos(rad);\n  const point = {x: centerX + sin * radius, y: centerY - cos * radius};\n  return {\n    type: 'point',\n    optionScope: 'point',\n    properties: {\n      x: point.x,\n      y: point.y,\n      centerX: point.x,\n      centerY: point.y,\n      bX: centerX + sin * (radius + hitSize),\n      bY: centerY - cos * (radius + hitSize)\n    }\n  };\n}\n\nfunction pointIsInPolygon(points, x, y, useFinalPosition) {\n  let isInside = false;\n  let A = points[points.length - 1].getProps(['bX', 'bY'], useFinalPosition);\n  for (const point of points) {\n    const B = point.getProps(['bX', 'bY'], useFinalPosition);\n    if ((B.bY > y) !== (A.bY > y) && x < (A.bX - B.bX) * (y - B.bY) / (A.bY - B.bY) + B.bX) {\n      isInside = !isInside;\n    }\n    A = B;\n  }\n  return isInside;\n}\n\nconst annotationTypes = {\n  box: BoxAnnotation,\n  doughnutLabel: DoughnutLabelAnnotation,\n  ellipse: EllipseAnnotation,\n  label: LabelAnnotation,\n  line: LineAnnotation,\n  point: PointAnnotation,\n  polygon: PolygonAnnotation\n};\n\n/**\n * Register fallback for annotation elements\n * For example lineAnnotation options would be looked through:\n * - the annotation object (options.plugins.annotation.annotations[id])\n * - element options (options.elements.lineAnnotation)\n * - element defaults (defaults.elements.lineAnnotation)\n * - annotation plugin defaults (defaults.plugins.annotation, this is what we are registering here)\n */\nObject.keys(annotationTypes).forEach(key => {\n  defaults.describe(`elements.${annotationTypes[key].id}`, {\n    _fallback: 'plugins.annotation.common'\n  });\n});\n\nconst directUpdater = {\n  update: Object.assign\n};\n\nconst hooks$1 = eventHooks.concat(elementHooks);\nconst resolve = (value, optDefs) => isObject(optDefs) ? resolveObj(value, optDefs) : value;\n\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import(\"chart.js\").UpdateMode } UpdateMode\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\n */\n\n/**\n * @param {string} prop\n * @returns {boolean}\n */\nconst isIndexable = (prop) => prop === 'color' || prop === 'font';\n\n/**\n * Resolve the annotation type, checking if is supported.\n * @param {string} [type=line] - annotation type\n * @returns {string} resolved annotation type\n */\nfunction resolveType(type = 'line') {\n  if (annotationTypes[type]) {\n    return type;\n  }\n  console.warn(`Unknown annotation type: '${type}', defaulting to 'line'`);\n  return 'line';\n}\n\n/**\n * @param {Chart} chart\n * @param {Object} state\n * @param {AnnotationPluginOptions} options\n * @param {UpdateMode} mode\n */\nfunction updateElements(chart, state, options, mode) {\n  const animations = resolveAnimations(chart, options.animations, mode);\n\n  const annotations = state.annotations;\n  const elements = resyncElements(state.elements, annotations);\n\n  for (let i = 0; i < annotations.length; i++) {\n    const annotationOptions = annotations[i];\n    const element = getOrCreateElement(elements, i, annotationOptions.type);\n    const resolver = annotationOptions.setContext(getContext(chart, element, elements, annotationOptions));\n    const properties = element.resolveElementProperties(chart, resolver);\n\n    properties.skip = toSkip(properties);\n\n    if ('elements' in properties) {\n      updateSubElements(element, properties.elements, resolver, animations);\n      // Remove the sub-element definitions from properties, so the actual elements\n      // are not overwritten by their definitions\n      delete properties.elements;\n    }\n\n    if (!defined(element.x)) {\n      // If the element is newly created, assing the properties directly - to\n      // make them readily awailable to any scriptable options. If we do not do this,\n      // the properties retruned by `resolveElementProperties` are available only\n      // after options resolution.\n      Object.assign(element, properties);\n    }\n\n    Object.assign(element, properties.initProperties);\n    properties.options = resolveAnnotationOptions(resolver);\n\n    animations.update(element, properties);\n  }\n}\n\nfunction toSkip(properties) {\n  return isNaN(properties.x) || isNaN(properties.y);\n}\n\nfunction resolveAnimations(chart, animOpts, mode) {\n  if (mode === 'reset' || mode === 'none' || mode === 'resize') {\n    return directUpdater;\n  }\n  return new Animations(chart, animOpts);\n}\n\nfunction updateSubElements(mainElement, elements, resolver, animations) {\n  const subElements = mainElement.elements || (mainElement.elements = []);\n  subElements.length = elements.length;\n  for (let i = 0; i < elements.length; i++) {\n    const definition = elements[i];\n    const properties = definition.properties;\n    const subElement = getOrCreateElement(subElements, i, definition.type, definition.initProperties);\n    const subResolver = resolver[definition.optionScope].override(definition);\n    properties.options = resolveAnnotationOptions(subResolver);\n    animations.update(subElement, properties);\n  }\n}\n\nfunction getOrCreateElement(elements, index, type, initProperties) {\n  const elementClass = annotationTypes[resolveType(type)];\n  let element = elements[index];\n  if (!element || !(element instanceof elementClass)) {\n    element = elements[index] = new elementClass();\n    Object.assign(element, initProperties);\n  }\n  return element;\n}\n\nfunction resolveAnnotationOptions(resolver) {\n  const elementClass = annotationTypes[resolveType(resolver.type)];\n  const result = {};\n  result.id = resolver.id;\n  result.type = resolver.type;\n  result.drawTime = resolver.drawTime;\n  Object.assign(result,\n    resolveObj(resolver, elementClass.defaults),\n    resolveObj(resolver, elementClass.defaultRoutes));\n  for (const hook of hooks$1) {\n    result[hook] = resolver[hook];\n  }\n  return result;\n}\n\nfunction resolveObj(resolver, defs) {\n  const result = {};\n  for (const prop of Object.keys(defs)) {\n    const optDefs = defs[prop];\n    const value = resolver[prop];\n    if (isIndexable(prop) && isArray(value)) {\n      result[prop] = value.map((item) => resolve(item, optDefs));\n    } else {\n      result[prop] = resolve(value, optDefs);\n    }\n  }\n  return result;\n}\n\nfunction getContext(chart, element, elements, annotation) {\n  return element.$context || (element.$context = Object.assign(Object.create(chart.getContext()), {\n    element,\n    get elements() {\n      return elements.filter((el) => el && el.options);\n    },\n    id: annotation.id,\n    type: 'annotation'\n  }));\n}\n\nfunction resyncElements(elements, annotations) {\n  const count = annotations.length;\n  const start = elements.length;\n\n  if (start < count) {\n    const add = count - start;\n    elements.splice(start, 0, ...new Array(add));\n  } else if (start > count) {\n    elements.splice(count, start - count);\n  }\n  return elements;\n}\n\nvar version = \"3.1.0\";\n\nconst chartStates = new Map();\nconst isNotDoughnutLabel = annotation => annotation.type !== 'doughnutLabel';\nconst hooks = eventHooks.concat(elementHooks);\n\nvar annotation = {\n  id: 'annotation',\n\n  version,\n\n  beforeRegister() {\n    requireVersion('chart.js', '4.0', Chart.version);\n  },\n\n  afterRegister() {\n    Chart.register(annotationTypes);\n  },\n\n  afterUnregister() {\n    Chart.unregister(annotationTypes);\n  },\n\n  beforeInit(chart) {\n    chartStates.set(chart, {\n      annotations: [],\n      elements: [],\n      visibleElements: [],\n      listeners: {},\n      listened: false,\n      moveListened: false,\n      hooks: {},\n      hooked: false,\n      hovered: []\n    });\n  },\n\n  beforeUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    const annotations = state.annotations = [];\n\n    let annotationOptions = options.annotations;\n    if (isObject(annotationOptions)) {\n      Object.keys(annotationOptions).forEach(key => {\n        const value = annotationOptions[key];\n        if (isObject(value)) {\n          value.id = key;\n          annotations.push(value);\n        }\n      });\n    } else if (isArray(annotationOptions)) {\n      annotations.push(...annotationOptions);\n    }\n    verifyScaleOptions(annotations.filter(isNotDoughnutLabel), chart.scales);\n  },\n\n  afterDataLimits(chart, args) {\n    const state = chartStates.get(chart);\n    adjustScaleRange(chart, args.scale, state.annotations.filter(isNotDoughnutLabel).filter(a => a.display && a.adjustScaleRange));\n  },\n\n  afterUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    updateListeners(chart, state, options);\n    updateElements(chart, state, options, args.mode);\n    state.visibleElements = state.elements.filter(el => !el.skip && el.options.display);\n    updateHooks(chart, state, options);\n  },\n\n  beforeDatasetsDraw(chart, _args, options) {\n    draw(chart, 'beforeDatasetsDraw', options.clip);\n  },\n\n  afterDatasetsDraw(chart, _args, options) {\n    draw(chart, 'afterDatasetsDraw', options.clip);\n  },\n\n  beforeDatasetDraw(chart, _args, options) {\n    draw(chart, _args.index, options.clip);\n  },\n\n  beforeDraw(chart, _args, options) {\n    draw(chart, 'beforeDraw', options.clip);\n  },\n\n  afterDraw(chart, _args, options) {\n    draw(chart, 'afterDraw', options.clip);\n  },\n\n  beforeEvent(chart, args, options) {\n    const state = chartStates.get(chart);\n    if (handleEvent(state, args.event, options)) {\n      args.changed = true;\n    }\n  },\n\n  afterDestroy(chart) {\n    chartStates.delete(chart);\n  },\n\n  getAnnotations(chart) {\n    const state = chartStates.get(chart);\n    return state ? state.elements : [];\n  },\n\n  // only for testing\n  _getAnnotationElementsAtEventForMode(visibleElements, event, options) {\n    return getElements(visibleElements, event, options);\n  },\n\n  defaults: {\n    animations: {\n      numbers: {\n        properties: ['x', 'y', 'x2', 'y2', 'width', 'height', 'centerX', 'centerY', 'pointX', 'pointY', 'radius'],\n        type: 'number'\n      },\n      colors: {\n        properties: ['backgroundColor', 'borderColor'],\n        type: 'color'\n      }\n    },\n    clip: true,\n    interaction: {\n      mode: undefined,\n      axis: undefined,\n      intersect: undefined\n    },\n    common: {\n      drawTime: 'afterDatasetsDraw',\n      init: false,\n      label: {\n      }\n    }\n  },\n\n  descriptors: {\n    _indexable: false,\n    _scriptable: (prop) => !hooks.includes(prop) && prop !== 'init',\n    annotations: {\n      _allKeys: false,\n      _fallback: (prop, opts) => `elements.${annotationTypes[resolveType(opts.type)].id}`\n    },\n    interaction: {\n      _fallback: true\n    },\n    common: {\n      label: {\n        _indexable: isIndexable,\n        _fallback: true\n      },\n      _indexable: isIndexable\n    }\n  },\n\n  additionalOptionScopes: ['']\n};\n\nfunction draw(chart, caller, clip) {\n  const {ctx, chartArea} = chart;\n  const state = chartStates.get(chart);\n\n  if (clip) {\n    clipArea(ctx, chartArea);\n  }\n\n  const drawableElements = getDrawableElements(state.visibleElements, caller).sort((a, b) => a.element.options.z - b.element.options.z);\n  for (const item of drawableElements) {\n    drawElement(ctx, chartArea, state, item);\n  }\n\n  if (clip) {\n    unclipArea(ctx);\n  }\n}\n\nfunction getDrawableElements(elements, caller) {\n  const drawableElements = [];\n  for (const el of elements) {\n    if (el.options.drawTime === caller) {\n      drawableElements.push({element: el, main: true});\n    }\n    if (el.elements && el.elements.length) {\n      for (const sub of el.elements) {\n        if (sub.options.display && sub.options.drawTime === caller) {\n          drawableElements.push({element: sub});\n        }\n      }\n    }\n  }\n  return drawableElements;\n}\n\nfunction drawElement(ctx, chartArea, state, item) {\n  const el = item.element;\n  if (item.main) {\n    invokeHook(state, el, 'beforeDraw');\n    el.draw(ctx, chartArea);\n    invokeHook(state, el, 'afterDraw');\n  } else {\n    el.draw(ctx, chartArea);\n  }\n}\n\nexport { annotation as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}